//--------------------------------------------------------
// ORVarianTPSModel
// Created by Mark  A. Howe on Wed 12/2/09
// Code partially generated by the OrcaCodeWizard. Written by Mark A. Howe.
// Copyright (c) 2009 University of North Carolina. All rights reserved.
//-----------------------------------------------------------
//This program was prepared for the Regents of the University of 
//Washington at the Center for Experimental Nuclear Physics and 
//Astrophysics (CENPA) sponsored in part by the United States 
//Department of Energy (DOE) under Grant #DE-FG02-97ER41020. 
//The University has certain rights in the program pursuant to 
//the contract and the program should not be copied or distributed 
//outside your organization.  The DOE and the University of 
//Washington reserve all rights in the program. Neither the authors,
//University of Washington, or U.S. Government make any warranty, 
//express or implied, or assume any liability or responsibility 
//for the use of this software.
//-------------------------------------------------------------

#pragma mark •••Imported Files

#import "ORVarianTPSModel.h"
#import "ORSerialPort.h"
#import "ORSerialPortAdditions.h"
#import "ORDataTypeAssigner.h"
#import "ORDataPacket.h"
#import "ORTimeRate.h"
#import "ORSafeQueue.h"

#pragma mark •••External Strings
NSString* ORVarianTPSModelTmpRotSetChanged		= @"ORVarianTPSModelTmpRotSetChanged";
NSString* ORVarianTPSModelPressureScaleChanged	= @"ORVarianTPSModelPressureScaleChanged";
NSString* ORVarianTPSModelStationPowerChanged	= @"ORVarianTPSModelStationPowerChanged";
NSString* ORVarianTPSModelMotorPowerChanged		= @"ORVarianTPSModelMotorPowerChanged";
NSString* ORVarianTPSModelPressureChanged		= @"ORVarianTPSModelPressureChanged";
NSString* ORVarianTPSModelMotorCurrentChanged	= @"ORVarianTPSModelMotorCurrentChanged";
NSString* ORVarianTPSModelActualRotorSpeedChanged = @"ORVarianTPSModelActualRotorSpeedChanged";
NSString* ORVarianTPSModelSetRotorSpeedChanged	= @"ORVarianTPSModelSetRotorSpeedChanged";
NSString* ORVarianTPSTurboStateChanged			= @"ORVarianTPSTurboStateChanged";
NSString* ORVarianTPSModelDeviceAddressChanged	= @"ORVarianTPSModelDeviceAddressChanged";
NSString* ORVarianTPSModelPollTimeChanged		= @"ORVarianTPSModelPollTimeChanged";
NSString* ORVarianTPSModelSerialPortChanged		= @"ORVarianTPSModelSerialPortChanged";
NSString* ORVarianTPSModelPortNameChanged		= @"ORVarianTPSModelPortNameChanged";
NSString* ORVarianTPSModelPortStateChanged		= @"ORVarianTPSModelPortStateChanged";
NSString* ORVarianTPSTurboAcceleratingChanged	= @"ORVarianTPSTurboAcceleratingChanged";
NSString* ORVarianTPSTurboSpeedAttainedChanged	= @"ORVarianTPSTurboSpeedAttainedChanged";
NSString* ORVarianTPSTurboOverTempChanged		= @"ORVarianTPSTurboOverTempChanged";
NSString* ORVarianTPSDriveOverTempChanged		= @"ORVarianTPSDriveOverTempChanged";
NSString* ORVarianTPSOilDeficiencyChanged		= @"ORVarianTPSOilDeficiencyChanged";
NSString* ORVarianTPSLock						= @"ORVarianTPSLock";

#pragma mark •••Status Parameters
#define kTMPRotSet		707
#define kDeviceAddress	797
#define kOilDeficiency	301
#define kTempDriveUnit	304
#define kTempTurbo		305
#define kSpeedAttained	306
#define kAccelerating	307
#define kSetSpeed		308
#define kActualSpeed	309
#define kMotorCurrent	310
#define kPressure		340
#define kUnitName		350
#define kStandby		2
#define kStationPower	10
#define kMotorPower		23
#define kRemoteOps		28

@interface ORVarianTPSModel (private)
- (NSString*) formatExp:(float)aFloat;
- (void)	timeout;
- (void)	processOneCommandFromQueue;
- (int)		checkSum:(NSString*)aString;
- (void)	enqueCmdData:(NSData*)someData;
- (void)	processReceivedData:(NSData*)aCommand;
- (BOOL)	extractBool:(NSString*)aCommand;
- (int)		extractInt:(NSString*)aCommand;
- (float)	extractFloat:(NSData*)aCommand;
- (NSString*) extractString:(NSString*)aCommand;
- (void) clearAlarms;
@end

@implementation ORVarianTPSModel

- (void) dealloc
{
    [NSObject cancelPreviousPerformRequestsWithTarget:self];
	[cmdQueue release];
	[lastRequest release];
	[inComingData release];
    [noOilAlarm clearAlarm];
    [noOilAlarm release];
	
	[super dealloc];
}

- (void)sleep
{
    [super sleep];
    	
    [noOilAlarm clearAlarm];
    [noOilAlarm release];
    noOilAlarm = nil;
}

- (void) setUpImage
{
	[self setImage:[NSImage imageNamed:@"VarianTPS.tif"]];
}

- (void) makeMainController
{
	[self linkToController:@"ORVarianTPSController"];
}

#pragma mark •••Accessors
- (int) tmpRotSet
{
    return tmpRotSet;
}

- (void) setTmpRotSet:(int)aTmpRotSet
{
	if(aTmpRotSet<20)aTmpRotSet = 20;
	else if(aTmpRotSet>100)aTmpRotSet=100;
    [[[self undoManager] prepareWithInvocationTarget:self] setTmpRotSet:tmpRotSet];
    tmpRotSet = aTmpRotSet;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORVarianTPSModelTmpRotSetChanged object:self];
}

- (int) pollTime
{
    return pollTime;
}

- (void) setPollTime:(int)aPollTime
{
    [[[self undoManager] prepareWithInvocationTarget:self] setPollTime:pollTime];
    pollTime = aPollTime;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORVarianTPSModelPollTimeChanged object:self];
	
	if(pollTime){
		[self performSelector:@selector(pollPressures) withObject:nil afterDelay:pollTime];
	}
	else {
		[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(pollPressures) object:nil];
	}
}

- (void) pollPressures
{
	[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(pollPressures) object:nil];
	[self updateAll];
	[self performSelector:@selector(pollPressures) withObject:nil afterDelay:pollTime];
}

- (float) pressureScaleValue
{
	return pressureScaleValue;
}

- (int) pressureScale
{
    return pressureScale;
}

- (void) setPressureScale:(int)aPressureScale
{
	if(aPressureScale<0)aPressureScale=0;
	else if(aPressureScale>11)aPressureScale=11;
	
    [[[self undoManager] prepareWithInvocationTarget:self] setPressureScale:pressureScale];
    
    pressureScale = aPressureScale;
	
	pressureScaleValue = powf(10.,(float)pressureScale);
	
    [[NSNotificationCenter defaultCenter] postNotificationName:ORVarianTPSModelPressureScaleChanged object:self];
}

- (ORTimeRate*)timeRate
{
	return timeRate;
}

- (BOOL) stationPower
{
    return stationPower;
}

- (void) setStationPower:(BOOL)aStationPower
{
    stationPower = aStationPower;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORVarianTPSModelStationPowerChanged object:self];
}

- (BOOL) motorPower
{
    return motorPower;
}

- (void) setMotorPower:(BOOL)aMotorPower
{
    motorPower = aMotorPower;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORVarianTPSModelMotorPowerChanged object:self];
}

- (float) pressure
{
    return pressure;
}

- (void) setPressure:(float)aPressure
{
    pressure = aPressure;
	if(timeRate == nil) timeRate = [[ORTimeRate alloc] init];
	[timeRate addDataToTimeAverage:aPressure];
    [[NSNotificationCenter defaultCenter] postNotificationName:ORVarianTPSModelPressureChanged object:self];
}

- (float) motorCurrent
{
    return motorCurrent;
}

- (void) setMotorCurrent:(float)aMotorCurrent
{
    motorCurrent = aMotorCurrent;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORVarianTPSModelMotorCurrentChanged object:self];
}


- (int) actualRotorSpeed
{
    return actualRotorSpeed;
}

- (void) setActualRotorSpeed:(int)aActualRotorSpeed
{
    actualRotorSpeed = aActualRotorSpeed;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORVarianTPSModelActualRotorSpeedChanged object:self];
}

- (int) setRotorSpeed
{
    return setRotorSpeed;
}

- (void) setSetRotorSpeed:(int)aSetRotorSpeed
{
    setRotorSpeed = aSetRotorSpeed;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORVarianTPSModelSetRotorSpeedChanged object:self];
}

- (BOOL) turboAccelerating
{
    return turboAccelerating;
}

- (void) setTurboAccelerating:(BOOL)aTurboAccelerating
{
    turboAccelerating = aTurboAccelerating;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORVarianTPSTurboAcceleratingChanged object:self];
}

- (BOOL) speedAttained
{
    return speedAttained;
}

- (void) setSpeedAttained:(BOOL)aSpeedAttained
{
    speedAttained = aSpeedAttained;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORVarianTPSTurboSpeedAttainedChanged object:self];
}

- (BOOL) turboPumpOverTemp
{
    return turboPumpOverTemp;
}

- (void) setTurboPumpOverTemp:(BOOL)aTurboPumpOverTemp
{
    turboPumpOverTemp = aTurboPumpOverTemp;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORVarianTPSTurboOverTempChanged object:self];
}

- (BOOL) driveUnitOverTemp
{
    return driveUnitOverTemp;
}

- (void) setDriveUnitOverTemp:(BOOL)aDriveUnitOverTemp
{
    driveUnitOverTemp = aDriveUnitOverTemp;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORVarianTPSDriveOverTempChanged object:self];
}

- (BOOL) oilDeficiency
{
    return oilDeficiency;
}

- (void) setOilDeficiency:(BOOL)aOilDeficiency
{    
    oilDeficiency = aOilDeficiency;
	if(oilDeficiency){
		if(!noOilAlarm){
			NSString* s = [NSString stringWithFormat:@"No Oil -- DCU %d",[self uniqueIdNumber]];
			noOilAlarm = [[ORAlarm alloc] initWithName:s severity:kImportantAlarm];
			[noOilAlarm setSticky:YES];
			[noOilAlarm setHelpStringFromFile:@"NoOilHelp"];
			[noOilAlarm setAcknowledged:NO];
		}                      
		[noOilAlarm postAlarm];
	}
	else {
		if(noOilAlarm){
			[noOilAlarm clearAlarm];
			[noOilAlarm release];
			noOilAlarm = nil;
		}
	}
    [[NSNotificationCenter defaultCenter] postNotificationName:ORVarianTPSOilDeficiencyChanged object:self];
}

- (int) deviceAddress
{
    return deviceAddress;
}

- (void) setDeviceAddress:(int)aDeviceAddress
{
	//if(aDeviceAddress<1)aDeviceAddress = 1;
	//else if(aDeviceAddress>255)aDeviceAddress= 255;
	
    [[[self undoManager] prepareWithInvocationTarget:self] setDeviceAddress:deviceAddress];
	if([serialPort isOpen]){
		//[self sendDataSet:kDeviceAddress integer:aDeviceAddress];
	}
    deviceAddress = aDeviceAddress;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORVarianTPSModelDeviceAddressChanged object:self];
}

- (NSData*) lastRequest
{
	return lastRequest;
}

- (void) setLastRequest:(NSData*)aCmdData
{
	[aCmdData retain];
	[lastRequest release];
	lastRequest = aCmdData;
}

- (void) openPort:(BOOL)state
{
    if(state) {
		[serialPort setSpeed:9600];
		[serialPort setParityNone];
		[serialPort setStopBits2:NO];
		[serialPort setDataBits:8];
        [serialPort open];
		[serialPort setDelegate:self];
    }
    else {
		[serialPort close];
		[self clearAlarms];
	}
    portWasOpen = [serialPort isOpen];
    [[NSNotificationCenter defaultCenter] postNotificationName:ORSerialPortModelPortStateChanged object:self];
    
}

#pragma mark •••Archival
- (id) initWithCoder:(NSCoder*)decoder
{
	self = [super initWithCoder:decoder];
	[[self undoManager] disableUndoRegistration];
	[self setTmpRotSet:		[decoder decodeIntForKey:	@"tmpRotSet"]];
	[self setPollTime:		[decoder decodeIntForKey:	@"pollTime"]];
	[self setPressureScale:	[decoder decodeIntForKey:	@"pressureScale"]];
	[self setDeviceAddress:	[decoder decodeIntForKey:	@"deviceAddress"]];
	[[self undoManager] enableUndoRegistration];
	cmdQueue = [[ORSafeQueue alloc] init];
	
	return self;
}

- (void) encodeWithCoder:(NSCoder*)encoder
{
    [super encodeWithCoder:encoder];
    [encoder encodeInt:tmpRotSet		forKey:@"tmpRotSet"];
    [encoder encodeInt:pressureScale	forKey: @"pressureScale"];
    [encoder encodeInt:deviceAddress	forKey: @"deviceAddress"];
    [encoder encodeInt:pollTime			forKey: @"pollTime"];
}

#pragma mark •••HW Methods
- (void) initUnit
{
	[self sendTmpRotSet:[self tmpRotSet]];
}

- (void) getDeviceAddress	{ }
- (void) getTMPRotSet		{  }
- (void) getOilDeficiency	{  }
- (void) getTurboTemp		{ }
- (void) getDriveTemp		{  }
- (void) getSpeedAttained	{  }
- (void) getAccelerating	{  }
- (void) getSetSpeed		{  }
- (void) getActualSpeed		{  }
- (void) getMotorCurrent	{  }
- (void) getPressure		{ [self read:224];  }
- (void) getMotorPower		{  }
- (void) getStationPower	{  }
- (void) getStandby			{  }
- (void) getUnitName		{  }

- (void) updateAll
{
	//[self getOilDeficiency];
	//[self getTurboTemp];
	//[self getDriveTemp];
	//[self getAccelerating];
	//[self getSpeedAttained];
	//[self getSetSpeed];
	//[self getActualSpeed];
	//[self getMotorCurrent];
	[self getPressure];
	//[self getStationPower];
	//[self getMotorPower];
}

- (void) sendTmpRotSet:(int)aValue
{
	[self sendDataSet:kTMPRotSet real:aValue];
}

- (void) sendMotorPower:(BOOL)aState
{
	[self sendDataSet:kMotorPower bool:aState];
}

- (void) sendStationPower:(BOOL)aState
{
	[self sendDataSet:kStationPower bool:aState];
}

- (void) sendStandby:(BOOL)aState
{
	[self sendDataSet:kStandby bool:aState];
}

- (void) turnStationOn
{
	[self write:0 logicValue:1];
}

- (void) turnStationOff
{
	[self write:0  logicValue:0];
}

#pragma mark •••Commands
- (int) crc:(unsigned char*)aCmd length:(int)len
{
	int i;
	int crc = 0;
	for(i=1;i<len;i++){
		crc ^= aCmd[i];
	}
	return crc;
}

- (void) write:(int)window logicValue:(BOOL)aValue 
{
	int d1 = window/100;
	int d2 = (window-d1*100)/10;
	int d3 = window - d1*100 - d2*10;
	unsigned char data[64];
	data[0] = 0x02;	//<STX>
	data[1] = 0x80; //addr -- always 0x80 for rs232
	data[2] = '0'+ d1;
	data[3] = '0'+ d2;
	data[4] = '0'+ d3;
	data[5] = 0x31; //write
	data[6] = '0'+ aValue;
	data[7] = 0x03; //<ETX>
	int crc = [self crc:data length:8];
	char c[64];
	sprintf(c,"%02X",crc);
	data[8] = c[0];
	data[9] = c[1];

	NSMutableData* cmdData = [NSMutableData dataWithBytes:data length:10];

	[self enqueCmdData:cmdData];
}
	
- (void) read:(int)window 
	{
	int d1 = window/100;
	int d2 = (window-d1*100)/10;
	int d3 = window - d1*100 - d2*10;
	unsigned char data[64];
	data[0] = 0x02;	//<STX>
	data[1] = 0x80; //addr -- always 0x80 for rs232
	data[2] = '0'+ d1;
	data[3] = '0'+ d2;
	data[4] = '0'+ d3;
	data[5] = 0x30; //read
	data[6] = 0x03; //<ETX>
	int crc = [self crc:data length:7];
	char c[64];
	sprintf(c,"%02X",crc);
	data[7] = c[0];
	data[8] = c[1];
	
	NSMutableData* cmdData = [NSMutableData dataWithBytes:data length:9];
	
	[self enqueCmdData:cmdData];
}
	

//---------------------------
//format of a command
//<STX> <Addr> <Win> <command> <data> <ETX> <CRC>
//Where:
//<STX> = 0x02
//<Addr>= 0x80
//<Win> = window number 0 - 999
//<command> = 0x30 to read, 0x31 to write
//<data> = data to be written (field not present for read)
//<ETX> = 0x03
//<CRC> = XOR of all characters subsequent to <STX> and including the <ETX> terminator
//---------------------------

- (void) sendDataSet:(int)aParamNum bool:(BOOL)aState 
{
}

- (void) sendDataSet:(int)aParamNum integer:(unsigned int)anInt 
{
}

- (void) sendDataSet:(int)aParamNum real:(float)aFloat 
{
}

- (void) sendDataSet:(int)aParamNum expo:(float)aFloat 
{
}

- (void) sendDataSet:(int)aParamNum shortInteger:(unsigned short)aShort 
{
}

#pragma mark •••Data Records
- (unsigned long) dataId { return dataId; }
- (void) setDataId: (unsigned long) DataId
{
    dataId = DataId;
}
- (void) setDataIds:(id)assigner
{
    dataId       = [assigner assignDataIds:kLongForm];
}

- (void) syncDataIdsWith:(id)anotherVarianTPS
{
    [self setDataId:[anotherVarianTPS dataId]];
}

- (void) appendDataDescription:(ORDataPacket*)aDataPacket userInfo:(id)userInfo
{
    //----------------------------------------------------------------------------------------
    // first add our description to the data description
    [aDataPacket addDataDescriptionItem:[self dataRecordDescription] forKey:@"VarianTPSModel"];
}

- (NSDictionary*) dataRecordDescription
{
    NSMutableDictionary* dataDictionary = [NSMutableDictionary dictionary];
    NSDictionary* aDictionary = [NSDictionary dictionaryWithObjectsAndKeys:
        @"ORVarianTPSDecoderForAdc",				@"decoder",
        [NSNumber numberWithLong:dataId],   @"dataId",
        [NSNumber numberWithBool:NO],       @"variable",
        [NSNumber numberWithLong:8],        @"length",
        nil];
    [dataDictionary setObject:aDictionary forKey:@"Adcs"];
    
    return dataDictionary;
}

- (void) dataReceived:(NSNotification*)note
{
	if(!lastRequest)return;
	
    if([[note userInfo] objectForKey:@"serialPort"] == serialPort){
		if(!inComingData)inComingData = [[NSMutableData data] retain];
		[inComingData appendData:[[note userInfo] objectForKey:@"data"]];
		
		do {
			char* p = (char*)[inComingData bytes];
			int i;
			NSLog(@"received: %@\n",inComingData);
			int n = [inComingData length];
			BOOL foundEnd = NO;
			for(i=0;i<n;i++){
				if(p[i] == 0x03 && n>=i+2){
					[self processReceivedData:[NSData dataWithBytes:p length:i+2]];
					[inComingData replaceBytesInRange:NSMakeRange(0,i+2) withBytes:nil length:0];
					foundEnd = YES;
					break;
				} 
			}
			if(!foundEnd) break;
		} while([inComingData length]!=0);
	}
}

- (void) decode:(int)paramNumber command:(NSData*)aCommand
{
	switch (paramNumber) {
		//case kStationPower:	 [self setStationPower:		[self extractBool:aCommand]]; break;
		//case kMotorPower:	 [self setMotorPower:		[self extractBool:aCommand]]; break;
		//case kOilDeficiency: [self setOilDeficiency:	[self extractBool:aCommand]]; break;
		//case kTempDriveUnit: [self setDriveUnitOverTemp:[self extractBool:aCommand]]; break;
		//case kTempTurbo:	 [self setTurboPumpOverTemp:[self extractBool:aCommand]]; break;
		//case kSpeedAttained: [self setSpeedAttained:	[self extractBool:aCommand]]; break;
		//case kAccelerating:  [self setTurboAccelerating:[self extractBool:aCommand]]; break;

		//case kSetSpeed:		[self setSetRotorSpeed:		[self extractInt:aCommand]];   break;
		//case kActualSpeed:  [self setActualRotorSpeed:	[self extractInt:aCommand]];   break;
		//case kMotorCurrent: [self setMotorCurrent:		[self extractFloat:aCommand]]; break;
		case kPressure:		[self setPressure:			[self extractFloat:aCommand]]; break;			
		//case kUnitName:		NSLog(@"DCU Unit: %@\n",	[self extractString:aCommand]);break;	
		default:
		break;
	}
}
@end

@implementation ORVarianTPSModel (private)
- (void) clearAlarms
{
	if(noOilAlarm){
		[noOilAlarm clearAlarm];
		[noOilAlarm release];
		noOilAlarm = nil;
	}	
}

- (BOOL)  extractBool: (NSString*)aCommand	{ return [[aCommand substringWithRange:NSMakeRange(10,6)] intValue]!=0; }
- (int)   extractInt:  (NSString*)aCommand	{ return [[aCommand substringWithRange:NSMakeRange(10,6)] intValue]; }

- (float) extractFloat:(NSData*)aCommand	
{ 
	if([aCommand length]>=16){
		NSString* s = [[NSString alloc] initWithData:[aCommand subdataWithRange:NSMakeRange(4,14)] encoding:NSASCIIStringEncoding];
		float theValue = [s floatValue];
		[s release];
		return theValue; 
	}
	else return 0;
}

- (NSString*) extractString:(NSString*)aCommand	
{
	int numChars = [[aCommand substringWithRange:NSMakeRange(8,2)] intValue];
	return [aCommand substringWithRange:NSMakeRange(10,numChars)];
}

- (void) timeout
{
	[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(timeout) object:nil];
	NSLogError(@"PAC",@"command timeout",nil);
	[self setLastRequest:nil];
	[cmdQueue removeAllObjects];
	[self processOneCommandFromQueue];	 //do the next command in the queue
}

- (void) processOneCommandFromQueue
{
	if([cmdQueue count] == 0) return;
	NSData* cmdData = [cmdQueue dequeue];
	[self setLastRequest:cmdData];
	[serialPort writeDataInBackground:cmdData];
	[self performSelector:@selector(timeout) withObject:nil afterDelay:.3];
}

- (int) checkSum:(NSString*)aString
{
	int i;
	int sum = 0;
	for(i=0;i<[aString length];i++){
		sum += (int)[aString characterAtIndex:i];
	}
	return sum%256;
}

- (void) enqueCmdData:(NSData*)someData
{
	if([serialPort isOpen]){
		[cmdQueue enqueue:someData];
		if(!lastRequest)[self processOneCommandFromQueue];
	}
}

- (NSString*) formatExp:(float)aFloat
{
	NSString* s = [NSString stringWithFormat:@"%.1E",aFloat];
	NSArray* parts = [s componentsSeparatedByString:@"E"];
	float m = [[parts objectAtIndex:0] floatValue];
	int e = [[parts objectAtIndex:1] intValue];
	s= [NSString stringWithFormat:@"%.1fE%d",m,e];
	s = [[s componentsSeparatedByString:@".0"] componentsJoinedByString:@""];
	int len = [s length];
	if(len<6){
		int i;
		for(i=0;i<6-len;i++){
			s = [NSString stringWithFormat:@"0%@",s];
		}
	}
	return s;
}

- (void) processReceivedData:(NSData*)aCommand
{
	BOOL doNextCommand = NO;
	unsigned char* p = (unsigned char*)[aCommand bytes];
	int receivedWindow = (p[2]-'0')*100 + (p[3]-'0')*10 + (p[4]-'0');
	[self decode:receivedWindow command:aCommand];
		
	if(lastRequest){
		//if the param number matches the last cmd sent, then assume a match and remove the timeout
		unsigned char* p = (unsigned char*)[lastRequest bytes];
		int lastWindow = (p[2]-'0')*100 + (p[3]-'0')*10 + (p[4]-'0');
		if(receivedWindow == lastWindow){
			[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(timeout) object:nil];
			[self setLastRequest:nil];			 //clear the last request
			doNextCommand = YES;
		}
	}
	
	if(doNextCommand){
		[ORTimer delay:.1];
		[self processOneCommandFromQueue];	 //do the next command in the queue
	}
}

@end