//--------------------------------------------------------
// ORRefClockModel
// Created by Mark  A. Howe on Fri Jul 22 2005 / Julius Hartmann, KIT, November 2017
// Code partially generated by the OrcaCodeWizard. Written by Mark A. Howe.
// Copyright (c) 2005 CENPA, University of Washington. All rights reserved.
//-----------------------------------------------------------
//This program was prepared for the Regents of the University of
//Washington at the Center for Experimental Nuclear Physics and
//Astrophysics (CENPA) sponsored in part by the United States
//Department of Energy (DOE) under Grant #DE-FG02-97ER41020.
//The University has certain rights in the program pursuant to
//the contract and the program should not be copied or distributed
//outside your organization.  The DOE and the University of
//Washington reserve all rights in the program. Neither the authors,
//University of Washington, or U.S. Government make any warranty,
//express or implied, or assume any liability or responsibility
//for the use of this software.
//-------------------------------------------------------------

#pragma mark ***Imported Files

#import "ORRefClockModel.h"
#import "ORSynClockModel.h"
#import "ORMotoGPSModel.h"
#import "ORSerialPort.h"
#import "ORSerialPortAdditions.h"

#pragma mark ***External Strings
NSString* ORRefClockModelVerboseChanged         = @"ORRefClockModelVerboseChanged";
NSString* ORRefClockModelTrackModeChanged	    = @"ORRefClockModelTrackModeChanged";
NSString* ORRefClockModelSyncChanged	        = @"ORRefClockModelSyncChanged";
NSString* ORRefClockModelAlarmWindowChanged	    = @"ORRefClockModelAlarmWindowChanged";
NSString* ORRefClockModelStatusChanged          = @"ORRefClockModelStatusChanged";
NSString* ORRefClockModelStatusPollChanged      = @"ORRefClockModelStatusPollChanged";
NSString* ORRefClockModelStatusOutputChanged    = @"ORRefClockModelStatusOutputChanged";
NSString* ORRefClockModelDeviceIDButtonChanged  = @"ORRefClockModelDeviceIDButtonChanged";
NSString* ORRefClockModelResetChanged           = @"ORRefClockModelResetChanged";
NSString* ORRefClockModelSerialPortChanged      = @"ORRefClockModelSerialPortChanged";
NSString* ORRefClockModelPortStateChanged       = @"ORRefClockModelPortStateChanged";
NSString* ORRefClockLock                        = @"ORRefClockLock";
NSString* ORSynClockDataAvailable               = @"ORSynClockDataAvailable";
NSString* ORMotoGPSClockDataAvailable           = @"ORMotoGPSClockDataAvailable";
NSString* ORSynClockStatusUpdated               = @"ORSynClockStatusUpdated";
NSString* ORSynClock                            = @"ORSynClock";
NSString* ORMotoGPS                             = @"ORMotoGPS";
//#define maxReTx 3  // above this number, stop trying to
// retransmit and place an Error.

@interface ORRefClockModel (private)
- (void) timeout;
- (void) processOneCommandFromQueue;
- (void) processResponse:(NSData*)someData;
@end

@implementation ORRefClockModel

- (void) dealloc
{
    [synClockModel  release];
    [motoGPSModel   release];
	[super dealloc];
}

- (void) setUpImage
{
	[self setImage:[NSImage imageNamed:@"RefClock"]];
}

- (void) makeMainController
{
	[self linkToController:@"ORRefClockController"];
}

- (NSString*) helpURL
{
	return @"RS232/RefClock.html";
}

#pragma mark ***Accessors

- (ORSynClockModel*) synClockModel{
    return synClockModel;
}
- (ORMotoGPSModel*) motoGPSModel{
    return motoGPSModel;
}

- (BOOL) verbose
{
    return verbose;
}

- (void) setVerbose:(BOOL)aVerbose
{
    [[[self undoManager] prepareWithInvocationTarget:self] setVerbose:verbose];

    verbose = aVerbose;
    
    NSDictionary *userInfo = [NSDictionary dictionaryWithObject:[NSNumber numberWithBool: verbose] forKey:@"verbose"];

    [[NSNotificationCenter defaultCenter] postNotificationName:ORRefClockModelVerboseChanged object:self userInfo:userInfo];
}

- (void) setLastRequest:(NSDictionary*)aRequest
{
	[aRequest retain];
	[lastRequest release];
	lastRequest = aRequest;
}

- (void) setPortName:(NSString*)aPortName
{
    //over-riden from super
    [[[self undoManager] prepareWithInvocationTarget:self] setPortName:portName];
    if(aPortName==nil)aPortName = @"";
    
    if(![aPortName isEqualToString:portName]){
        [portName autorelease];
        portName = [aPortName copy];
        
        ORSerialPort* aPort = [[ORSerialPort alloc] init:[self portName] withName:@"RefClock"];
        [self setSerialPort:aPort];
        [aPort release];
    }

    [[NSNotificationCenter defaultCenter] postNotificationName:ORSerialPortModelPortNameChanged object:self];
}

- (void) openPort:(BOOL)state
{
    if(state) {
        [serialPort open];
		[serialPort setSpeed:9600];
		[serialPort setParityNone];
		[serialPort setStopBits2:NO];
		[serialPort setDataBits:8];
 		[serialPort commitChanges];
        [serialPort setDelegate:self];
    }
    else      [serialPort close];
    portWasOpen = [serialPort isOpen];
    [[NSNotificationCenter defaultCenter] postNotificationName:ORSerialPortModelPortStateChanged object:self];

}
- (BOOL) portIsOpen
{
    return [serialPort isOpen];
}

//put our parameters into any run header
// todo
- (NSMutableDictionary*) addParametersToDictionary:(NSMutableDictionary*)dictionary
{
    NSMutableDictionary* objDictionary = [NSMutableDictionary dictionary];
    [objDictionary setObject:NSStringFromClass([self class]) forKey:@"Class Name"];

	[dictionary setObject:objDictionary forKey:[self identifier]];
	return objDictionary;
}


#pragma mark *** Commands
- (void) addCmdToQueue:(NSDictionary*)aCmd
{
    if([serialPort isOpen]){
        [self enqueueCmd:aCmd];
        if(!lastRequest){
            [self processOneCommandFromQueue];
        }
    }
}

- (void) dataReceived:(NSNotification*)note
{
    if([[note userInfo] objectForKey:@"serialPort"] == serialPort){
        [self processResponse:[[note userInfo] objectForKey:@"data"]];
    }
}

//- (void) writeToDevice:(NSDictionary*)someData
//{
//    NSLog(@"RefClock::writeToDevice queing...\n");
//    if(!cmdQueue)cmdQueue = [[ORSafeQueue alloc] init];
//    [cmdQueue enqueue:someData];
//    //[[NSNotificationCenter defaultCenter] postNotificationName:ORPacModelQueCountChanged object: self];
//    if(!lastRequest)[self processOneCommandFromQueue];
//}

// - (NSData*) progModeCommand{
//   unsigned char cmdData[7];
//   cmdData[0] = 'X'; cmdData[1] = kWGProgModCmd;
//   cmdData[2] = cmdData[3] = cmdData[4] = cmdData[5] = '0';
//   cmdData[6] =  67;
//   return [NSData dataWithBytes:cmdData length:7];
// }
//
// - (NSData*) progModeCmdReturned{  // this resembles the expected reply for the above command.
//   // Used to check if the device has responded as expected.
//   unsigned char cmdData[7];
//   cmdData[0] = 'X'; cmdData[1] = kWGProgModCmd;
//   cmdData[2] = 'f';  // matching the WG1220 documentation..
//   cmdData[3] = 'a';
//   cmdData[4] = 'i';
//   cmdData[5] = 'l';
//   cmdData[6] =  65;
//   return [NSData dataWithBytes:cmdData length:7];
// }
//
// - (NSData*) startProgCommand{
//   unsigned char cmdData[7];
//   cmdData[0] = 'X'; cmdData[1] = kWGStartProgCmd;  // 'B'
//   cmdData[2] = cmdData[3] = 0;
//   cmdData[4] = 3;  // sync position low byte
//   cmdData[5] = 1;  // channel nr.
//   cmdData[6] = cmdData[1] ^  cmdData[2] ^ cmdData[3] ^ cmdData[4] ^ cmdData[5];
//   return [NSData dataWithBytes:cmdData length:7];
// }
//
// - (NSData*) checkReadyForProg:(int) nPoints{  // Start-Ready-request: 'X','b',0,HIBYTE(an),LOBYTE(an),knr,CRC
//   unsigned char cmdData[7];
//   cmdData[0] = 'X'; cmdData[1] = kWGRdyPrgrmCmd;  // 'b'
//   cmdData[2] = '0';
//   cmdData[3] = nPoints >> 8;
//   cmdData[4] = nPoints & 0xFF;
//   cmdData[5] = 1;  // channel nr.
//   cmdData[6] = cmdData[1] ^  cmdData[2] ^ cmdData[3] ^ cmdData[4] ^ cmdData[5];
//   return [NSData dataWithBytes:cmdData length:7];
// }
//
// - (NSData*) isReadyForProgReturned{  // this is expected from the device when it signals redyness for the next command
//   unsigned char cmdData[7];
//   unsigned int nPoints = [arbWaveform count];
//   cmdData[0] = 'X'; cmdData[1] = kWGRdyPrgrmCmd;  // 'b'
//   cmdData[2] = '0';
//   cmdData[3] = nPoints >> 8;
//   cmdData[4] = nPoints & 0xFF;
//   cmdData[5] = 1; // ready-byte
//   cmdData[6] = cmdData[1] ^  cmdData[2] ^ cmdData[3] ^ cmdData[4] ^ cmdData[5];
//   return [NSData dataWithBytes:cmdData length:7];
// }
//
// - (NSData*) WGBytesFromFloat{
//   // only the upper 12 Bit of a 16 Bit Point are used by the 12-Bit WG1220. max Voltages: 0x0000:-10 (-1) V  0xFFF0:10(1)V ;
//   // min Voltages:0.2(0.02)V normal output (with attenuation)
//   unsigned nPoints = [arbWaveform count];
//  // NSPredicate *bPredicate = [NSPredicate predicateWithFormat:@"SELF beginswith[c] 'b'"];
//   NSPredicate *pred = [NSPredicate predicateWithFormat:@"floatValue > 1.0 || floatValue < -1.0"];
//   //filteredArr = [arbWaveform filteredArrayUsingPredicate:pred];
//   bool damp_output = ![[arbWaveform filteredArrayUsingPredicate:pred] count];  // no value above
//     // 2.0 V? then the -20dB filter should be used and all values multiplied by 10.
//   // are amplitudes in range?
//   pred = [NSPredicate predicateWithFormat:@"floatValue > 10.0 || floatValue < -10.0"];
//   if([[arbWaveform filteredArrayUsingPredicate:pred] count]){
//     NSLog(@"Error: Waveform contains entries with an amplitude larger than 10.0 V! \n");
//     return [NSData dataWithBytes:arbWaveBytes length:0];
//   }
//
//   if([self verbose]){
//     NSLog(@"arbWaveform count: %d \n", [arbWaveform count]);
//     NSLog(damp_output ? @"output will be damped (for more precision)! \n" : @"output will not be damped! \n");
//   }
//
//   int ivalue;
//   int point = 0;
//   //NSLog(@"arbWaveBytes[0] size: %d \n", sizeof(arbWaveBytes[0]));
//   for(NSNumber* value in arbWaveform){
//     float fvalue = [value floatValue];
//     if(damp_output)  // everything reduced by factor 10
//       fvalue *= 10.0;  // compensated by multiplying everything with 10
//     fvalue += 10.0;  // -10...+10V -> 0...20
//     ivalue = fvalue * 65535 / 20.0;
//     arbWaveBytes[point*2] = ivalue & 0xF0;  // from 16 Bits, only 12 upper are used
//     arbWaveBytes[point*2+1] = ivalue >> 8;
//     //NSLog(@"added Value (%f) #%d: LSB: %X (%X) MSB: %X (%X) \n", fvalue, point, ivalue & 0xF0, arbWaveBytes[point*2], ivalue >> 8, arbWaveBytes[point*2+1]);
//     point++;
//
//   }
//     //NSLog(@"Data to be returned: %@ \n", [NSData dataWithBytes:arbWaveBytes length:nPoints * 2]);
//   return [NSData dataWithBytes:arbWaveBytes length:nPoints * 2];
// }
//
// - (NSData*) stopProgCommand{  // Stop programming of arbitrary waveform
//   unsigned char cmdData[7];
//   cmdData[0] = 'X'; cmdData[1] = kWGStopPrgrmCmd;  // 'U'
//   cmdData[2] = cmdData[3] = 0;
//   cmdData[4] = 3;  // sync position low byte
//   cmdData[5] = 1;  // channel nr.
//   cmdData[6] = cmdData[1] ^  cmdData[2] ^ cmdData[3] ^ cmdData[4] ^ cmdData[5];
//   return [NSData dataWithBytes:cmdData length:7];
// }
// - (NSData*) checkStoppedProg:(int) nPoints{  // Poll if device is ready after arbitrary waveform transfer is completed
//   unsigned char cmdData[7];
//   cmdData[0] = 'X'; cmdData[1] = kWGFinPrgrmCmd;  // 'u'
//   cmdData[2] = '0';
//   cmdData[3] = nPoints >> 8;
//   cmdData[4] = nPoints & 0xFF;
//   cmdData[5] = 1;  // channel nr.
//   cmdData[6] = cmdData[1] ^  cmdData[2] ^ cmdData[3] ^ cmdData[4] ^ cmdData[5];
//   return [NSData dataWithBytes:cmdData length:7];
// }
//
// - (NSData*) isStoppedProgReturned{  // this is expected from the device when it signals redyness for the next command
//   unsigned char cmdData[7];
//   unsigned int nPoints = [arbWaveform count];
//   cmdData[0] = 'X'; cmdData[1] = kWGFinPrgrmCmd;  // 'u'
//   cmdData[2] = '0';
//   cmdData[3] = nPoints >> 8;
//   cmdData[4] = nPoints & 0xFF;
//   cmdData[5] = 1; // ready-byte
//   cmdData[6] = cmdData[1] ^  cmdData[2] ^ cmdData[3] ^ cmdData[4] ^ cmdData[5];
//   return [NSData dataWithBytes:cmdData length:7];
// }
//



// - (NSData*) signalFormCommand:(enum SignalForms) aCommand
// {
//   unsigned char cmdData[7];
//
//   cmdData[0] = 'X';
//   cmdData[1] = kWGFormCmd;
//
//   cmdData[3] ='0';
//
//   switch (aCommand){
//     case Sine:
//       cmdData[2] = 'S'; break;
//     case Rectangular:
//       cmdData[2] = 'R'; break;
//     case Triangular:
//       cmdData[2] = 'T'; break;
//     // case DC:
//     //   cmdData[2] = 'G'; break;
//     case Arbitrary:
//       cmdData[2] = 'D';
//       cmdData[3] = 1; break;
//     // case Noise:
//     //   cmdData[2] = 'N'; break;
//
//     default: cmdData[2] = 'S';
//
//   }
//
//   cmdData[4] = '0';
//   cmdData[5] = 0x80;
//
//   cmdData[6] = cmdData[1] ^  cmdData[2] ^ cmdData[3] ^ cmdData[4] ^ cmdData[5];
//   return [NSData dataWithBytes:cmdData length:7];
// }

#pragma mark ***Archival
- (id)initWithCoder:(NSCoder*)decoder
{
    self = [super initWithCoder:decoder];
    [[self undoManager] disableUndoRegistration];
    
    synClockModel = [[decoder decodeObjectForKey:@"synClockModel"] retain];
    motoGPSModel  = [[decoder decodeObjectForKey:@"motoGPSModel"] retain];
    if(!synClockModel) synClockModel = [[ORSynClockModel alloc]init];
    if(!motoGPSModel)  motoGPSModel  = [[ORMotoGPSModel alloc]init];
    [synClockModel setRefClock:self];
    [motoGPSModel  setRefClock:self];

    [[self undoManager] enableUndoRegistration];
    return self;
}

- (void)encodeWithCoder:(NSCoder*)encoder  // todo: function needed?
{
    [super encodeWithCoder:encoder];
    [encoder encodeObject:synClockModel    forKey:@"synClockModel"];
    [encoder encodeObject:synClockModel    forKey:@"motoGPSModel"];
}
- (void)serialPortWriteProgress:(NSDictionary *)dataDictionary
{  // this function is required to writeDataInBackground via Serial Port
}
@end

@implementation ORRefClockModel (private)

- (void) processOneCommandFromQueue
{
    NSDictionary* aCmdDictionary = [self nextCmd];
    if(aCmdDictionary){
        NSData* cmdData = [aCmdDictionary objectForKey:@"data"];
        [self startTimeout:3];
        [self setLastRequest:aCmdDictionary];
        [serialPort writeDataInBackground:cmdData];
    }
}
- (void) processResponse:(NSData*)someData
{
    //process the incoming data here and pass it to either the gps or the synclock
    if(!lastRequest)return;
    if(!inComingData)inComingData = [[NSMutableData data] retain];
    [inComingData appendData:someData];
    
    //while (((char*)[inComingData mutableBytes])[0] != 'X' && [inComingData length] > 0){  //  remove possible error bytes at beginning until 'X';
    // this can occur when the device has sent faulty data.
    //NSRange range = NSMakeRange(0, 1);
    //[inComingData replaceBytesInRange:range withBytes:NULL length:0];
    //if([self verbose]){
    //  NSLog(@"removed wrong starting Byte! \n");
    //}
    //}
    //int a = @40;
    //a = @50;
    unsigned short nBytes = [inComingData length];
    unsigned char* bytes  = (unsigned char *)[inComingData bytes];
    NSLog(@"receiving... (so far %d bytes ) \n", nBytes);
    [self startTimeout:3]; //reset incase there is a lot of data
    if([[lastRequest objectForKey:@"replySize"] intValue] == nBytes){
        //if([inComingData length] >= 7) {
        if(bytes[nBytes - 2] == '\r' && bytes[nBytes - 1] == '\n' ) { // check for trailing \n (LF)
            NSLog(@"received %s \n", bytes);
            //NSLog(@"lastRequest contains %d bytes", [lastRequest length]);
            //       char* lastCmd;
            //
            //        lastCmd = (char*)[lastRequest bytes];
            //        //}
            //
            //        if([self verbose]){
            //            NSLog(@"last command: %s \n", lastCmd);
            //        }
            
            //unsigned int senderDevice;  // extract the device here
            //senderDevice = (bytes[0] == '@' && bytes[1] == '@') ? 'MGPS' : 'SYCK';  // check if the last incoming Data came from the MOTOGPS Clock (first two chars are '@'); otherwise, the Synclock (which shares the serial connection) sent the last message.
            NSString* senderDevice = [lastRequest objectForKey:@"device"];
            if([senderDevice isEqualToString:ORSynClock]){
                [synClockModel processResponse:inComingData];
            }
            else if ([senderDevice isEqualToString:ORMotoGPS]){
                [motoGPSModel processResponse:inComingData];
            }
            
            [inComingData release];
            inComingData = nil;
            
            [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(timeout) object:nil];
            [self setLastRequest:nil];             //clear the last request
            [self processOneCommandFromQueue];     //do the next command in the queue
        }
    }
}
- (void) timeout  // todo
{
	@synchronized (self){
    NSLog(@"Warning: timeout (RefClock)! \n");
    // reTxCount++;  // schedule retransmission
    // if([self verbose]){
    //   NSLog(@"Warning: timeout (RefClock)! trying(%d) retransmit. \n", reTxCount);  //Request was: %@ \n", lastRequest);
    // }
    //
    // [cmdQueue enqueue:lastRequest];
		// //[[NSNotificationCenter defaultCenter] postNotificationName:ORPacModelQueCountChanged object: self];
		// [self processOneCommandFromQueue];	 //do the next command in the queue

    NSLog(@"Emptying remaining commands to RefClock... \n");
   [cmdQueue removeAllObjects];
   [self setLastRequest:nil];
   return;
	}
}



@end
