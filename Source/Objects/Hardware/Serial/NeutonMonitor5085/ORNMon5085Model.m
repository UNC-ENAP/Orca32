//--------------------------------------------------------
// ORNMon5085Model
// Created by Mark  A. Howe on Fri Oct 4, 2014
// Code partially generated by the OrcaCodeWizard. Written by Mark A. Howe.
// Copyright (c) 2013 University of North Carolina. All rights reserved.
//-----------------------------------------------------------
//This program was prepared for the Regents of the University of
//North Carolina  sponsored in part by the United States
//Department of Energy (DOE) under Grant #DE-FG02-97ER41020.
//The University has certain rights in the program pursuant to
//the contract and the program should not be copied or distributed
//outside your organization.  The DOE and the University of
//North Carolina reserve all rights in the program. Neither the authors,
//University of North Carolina, or U.S. Government make any warranty,
//express or implied, or assume any liability or responsibility
//for the us of this software.
//-------------------------------------------------------------

#pragma mark •••Imported Files

#import "ORNMon5085Model.h"
#import "ORSerialPort.h"
#import "ORSerialPortAdditions.h"
#import "ORTimeRate.h"

#pragma mark •••External Strings

NSString* ORNMon5085ModelHighVoltageChanged = @"ORNMon5085ModelHighVoltageChanged";
NSString* ORNMon5085ModelDeadtimeChanged = @"ORNMon5085ModelDeadtimeChanged";
NSString* ORNMon5085ModelActualModeChanged = @"ORNMon5085ModelActualModeChanged";
NSString* ORNMon5085ModelDiscriminatorChanged = @"ORNMon5085ModelDiscriminatorChanged";
NSString* ORNMon5085ModelCalibrationValueChanged = @"ORNMon5085ModelCalibrationValueChanged";
NSString* ORNMon5085ModelTimeUtilStopChanged = @"ORNMon5085ModelTimeUtilStopChanged";
NSString* ORNMon5085ModelIsRunningChanged    = @"ORNMon5085ModelIsRunningChanged";
NSString* ORNMon5085ModelUnitsChanged       = @"ORNMon5085ModelUnitsChanged";
NSString* ORNMon5085ModelRadValueChanged    = @"ORNMon5085ModelRadValueChanged";
NSString* ORNMon5085ModelModeTimeChanged    = @"ORNMon5085ModelModeTimeChanged";
NSString* ORNMon5085ModelModeChanged        = @"ORNMon5085ModelModeChanged";
NSString* ORNMon5085Lock                    = @"ORNMon5085Lock";
NSString* ORNMon5085IsLogChanged            = @"ORNMon5085IsLogChanged";

@interface ORNMon5085Model (private)
- (void) send:(NSString*)aCmd;
- (void) processReceivedString:(NSString*)aString;
@end

#define kHWPollTime 5

@implementation ORNMon5085Model
- (void) dealloc
{
    [timeRate release];
    [actualMode release];
    [dateMeasured release];
    [units release];
	[NSObject cancelPreviousPerformRequestsWithTarget:self];
	[inComingData release];
	[super dealloc];
}

- (void)sleep
{
	[NSObject cancelPreviousPerformRequestsWithTarget:self];
    [super sleep];
}

- (void) setUpImage
{
	[self setImage:[NSImage imageNamed:@"NMon5085.tif"]];
}

- (void) makeMainController
{
	[self linkToController:@"ORNMon5085Controller"];
}

#pragma mark •••Accessors

- (int) highVoltage
{
    return highVoltage;
}

- (void) setHighVoltage:(int)aHighVoltage
{
    highVoltage = aHighVoltage;

    [[NSNotificationCenter defaultCenter] postNotificationName:ORNMon5085ModelHighVoltageChanged object:self];
}

- (int) deadtime
{
    return deadtime;
}

- (void) setDeadtime:(int)aDeadtime
{
    deadtime = aDeadtime;

    [[NSNotificationCenter defaultCenter] postNotificationName:ORNMon5085ModelDeadtimeChanged object:self];
}

- (NSString*) actualMode
{
    if([actualMode length])    return actualMode;
    else return @"?";
}

- (void) setActualMode:(NSString*)aActualMode
{
    [actualMode autorelease];
    actualMode = [aActualMode copy];

    [[NSNotificationCenter defaultCenter] postNotificationName:ORNMon5085ModelActualModeChanged object:self];
}

- (int) discriminator
{
    return discriminator;
}

- (void) setDiscriminator:(int)aDiscriminator
{
    discriminator = aDiscriminator;

    [[NSNotificationCenter defaultCenter] postNotificationName:ORNMon5085ModelDiscriminatorChanged object:self];
}

- (float) calibrationValue
{
    return calibrationValue;
}

- (void) setCalibrationValue:(float)aCalibrationValue
{
    calibrationValue = aCalibrationValue;

    [[NSNotificationCenter defaultCenter] postNotificationName:ORNMon5085ModelCalibrationValueChanged object:self];
}

- (int) timeUtilStop
{
    return timeUtilStop;
}

- (void) setTimeUtilStop:(int)aTimeUtilStop
{
    if(timeUtilStop != aTimeUtilStop){
        [self setIsRunning:YES];
        [self performSelector:@selector(runTimeOut) withObject:nil afterDelay:kHWPollTime+3];
    }
    
    timeUtilStop = aTimeUtilStop;
    

    [[NSNotificationCenter defaultCenter] postNotificationName:ORNMon5085ModelTimeUtilStopChanged object:self];
}

- (BOOL) isRunning
{
    return isRunning;
}

- (void) setIsRunning:(BOOL)aVaue
{
    [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(runTimeOut) object:nil];
    isRunning = aVaue;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORNMon5085ModelIsRunningChanged object:self];
}

- (BOOL) isLog
{
    return isLog;
}

- (void) setIsLog:(BOOL)aIsLog
{
    [[[self undoManager] prepareWithInvocationTarget:self] setIsLog:isLog];
    isLog = aIsLog;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORNMon5085IsLogChanged object:self];
}

- (ORTimeRate*)timeRate
{
	return timeRate;
}

- (unsigned long) timeMeasured
{
    return timeMeasured;
}

- (NSDate*) dateMeasured
{
    return dateMeasured;
}

- (NSString*) units
{
    if([units length]==0)return @"--";
    else return units;
}

- (void) setUnits:(NSString*)aUnits
{
    [units autorelease];
    units = [aUnits copy];    
    [[NSNotificationCenter defaultCenter] postNotificationName:ORNMon5085ModelUnitsChanged object:self];
}

- (float) radValue
{
    return radValue;
}

- (void) setRadValue:(float)aRadValue
{
    [dateMeasured release];
    dateMeasured = [[NSDate date]retain];
    
    time_t	ut_Time;
    time(&ut_Time);
    timeMeasured = ut_Time;
    
    radValue = aRadValue;
    
    if(timeRate == nil) timeRate = [[ORTimeRate alloc] init];
    [timeRate addDataToTimeAverage:radValue];
        
    [[NSNotificationCenter defaultCenter] postNotificationName:ORNMon5085ModelRadValueChanged object:self];
}

- (void) runTimeOut
{
    [self setIsRunning:NO];
}

- (int) modeTime
{
    return modeTime;
}

- (void) setModeTime:(int)aValue
{
    [[[self undoManager] prepareWithInvocationTarget:self] setModeTime:modeTime];
    modeTime = aValue;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORNMon5085ModelModeTimeChanged object:self];
}

- (int) mode
{
    return mode;
}

- (void) setMode:(int)aMode
{
    [[[self undoManager] prepareWithInvocationTarget:self] setMode:mode];
    mode = aMode;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORNMon5085ModelModeChanged object:self];
}

- (void) setUpPort
{
	[serialPort setSpeed:9600];
	[serialPort setParityNone];
	[serialPort setStopBits2:NO];
	[serialPort setDataBits:8];
}

- (void) firstActionAfterOpeningPort
{
    [self pollHW];
}

#pragma mark •••Archival
- (id) initWithCoder:(NSCoder*)decoder
{
	self = [super initWithCoder:decoder];
	[[self undoManager] disableUndoRegistration];
	[self setIsLog:		[decoder decodeBoolForKey:@"isLog"]];
	[self setModeTime:  [decoder decodeIntForKey:@"modeTime"]];
    [self setMode:      [decoder decodeIntForKey:@"mode"]];
	[[self undoManager] enableUndoRegistration];
	
	return self;
}

- (void) encodeWithCoder:(NSCoder*)encoder
{
    [super encodeWithCoder:encoder];
    [encoder encodeBool:isLog	forKey:@"isLog"];
    [encoder encodeInt:modeTime forKey:@"modeTime"];
    [encoder encodeInt:mode		forKey:@"mode"];
}

#pragma mark •••Commands
- (void) sendMode
{
    NSString* modeCmd[4] = {@"R",@"I"};
    if(mode>=0 && mode<4){
        [self enqueueCmd:@"M"];
        [self enqueueCmd:modeCmd[mode]];
    }
}

- (void) sendTime
{
    if(mode == kNMon5085Integrate){
        
        int t = modeTime;
        int h = t / 3600;
        t = t % 3600;
        int m = t / 60;
        t = t % 60;
        int s = t;

        [self enqueueCmd:@"T"];
        [self enqueueCmd:[NSString stringWithFormat:@"%d",h]];
        [self enqueueCmd:[NSString stringWithFormat:@"%d",m]];
        [self enqueueCmd:[NSString stringWithFormat:@"%d",s]];
    }
}

- (void) initHW
{
    [self sendMode];
    [self sendTime];
}

- (void) toggleRun
{
    if(isRunning){
        if([actualMode isEqual:@"Integrate"])[self enqueueCmd:@"S"];
        else[self enqueueCmd:@"Q"];
    }
    [self initHW];
    [self sendSorQCommand];
}

- (void) sendSorQCommand
{
    if(mode == kNMon5085Integrate){
        [self enqueueCmd:@"S"];
        [self pollHW];
    }
    else [self enqueueCmd:@"Q"];
}

- (void) pollHW
{
    [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(pollHW) object:nil];
    [self enqueueCmd:@"V"];
    [self performSelector:@selector(pollHW) withObject:nil afterDelay:kHWPollTime];
}

- (void) enqueueCmd:(id)aCmd
{
    if(![(NSString*)aCmd hasSuffix:@"\r"])aCmd = [(NSString*)aCmd stringByAppendingString:@"\r"];
    [super enqueueCmd:aCmd];
    [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(sendNextCmd) object:nil];
    [self performSelector:@selector(sendNextCmd) withObject:nil afterDelay:.3];

}
    
- (void) sendNextCmd
{
    [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(sendNextCmd) object:nil];
    id aCmd = [self nextCmd];
    if(aCmd){
        [serialPort writeString:aCmd];
        [self performSelector:@selector(sendNextCmd) withObject:nil afterDelay:.3];
    }
}

- (void) dataReceived:(NSNotification*)note
{	
    if([[note userInfo] objectForKey:@"serialPort"] == serialPort){
		if(!inComingData)inComingData = [[NSMutableData data] retain];
        [inComingData appendData:[[note userInfo] objectForKey:@"data"]];
        NSRange r;
        NSString* s;
        
        int i;
        for(i=0;i<[inComingData length];i++){
            unsigned char* p = (unsigned char*)[inComingData bytes];
            if(*p == '\n' || *p == '\n' || *p == ' ' || *p == '*'){
                [inComingData replaceBytesInRange:NSMakeRange(0,1) withBytes:nil length:0];
            }
            else break;
        }
        
        s = [[[NSString alloc] initWithData:inComingData encoding:NSASCIIStringEncoding] autorelease];
        r = [s rangeOfString:@"\n"];
        if(r.location!=NSNotFound){
            [self processReceivedString:s];
            [inComingData replaceBytesInRange:NSMakeRange(0,r.location) withBytes:nil length:0];
        }

        s = [[[NSString alloc] initWithData:inComingData encoding:NSASCIIStringEncoding] autorelease];
        r = [s rangeOfString:@"\r"];
        if(r.location!=NSNotFound){
            [self processReceivedString:s];
            [inComingData replaceBytesInRange:NSMakeRange(0,r.location) withBytes:nil length:0];
        }
	}
}
- (void) processReceivedString:(NSString*)aString
{
    aString = [aString stringByReplacingOccurrencesOfString:@"*" withString:@""];
    aString = [aString removeExtraSpaces];
    aString = [aString trimSpacesFromEnds];
    
    if([aString length]==0)return;
    else if([aString rangeOfString:@"?"].location != NSNotFound)return;
    else {
        @try {
            if([aString rangeOfString:@"mrem/h"].location!= NSNotFound){                            
                [self setRadValue:[aString floatValue]];
                NSArray* parts = [aString componentsSeparatedByString:@" "];
                if([parts count]>=2) [self setUnits:[[parts objectAtIndex:1] substringToIndex:6]];
                
                [self setIsRunning:YES];
                [self performSelector:@selector(runTimeOut) withObject:nil afterDelay:3];
                //no polling in this mode
                [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(pollHW) object:nil];
            }
            else if([aString hasPrefix:@"rate mode"])      [self setActualMode:@"Rate"];
            else if([aString hasPrefix:@"integrate mode"]) [self setActualMode:@"Integrate"];
            else if([aString hasPrefix:@"discriminator:"]) [self setDiscriminator:[[aString substringFromIndex:14] intValue]];
            else if([aString hasPrefix:@"deadtime:"])      [self setDeadtime:[[aString substringFromIndex:9] intValue]];
            else if([aString hasPrefix:@"HV:"])            [self setHighVoltage:[[aString substringFromIndex:4] intValue]];
            else if([aString hasPrefix:@"calibration:"])   [self setCalibrationValue:[[aString substringFromIndex:12] floatValue]];
            else if([aString hasPrefix:@"time ="])         [self setTimeUtilStop:[self processHHMMSS:[aString substringWithRange:NSMakeRange(7,8)]]];
            else if([aString rangeOfString:@"stop time:"].location!=NSNotFound){
                [self setTimeUtilStop:[self processHHMMSS:[aString substringFromIndex:[aString rangeOfString:@"stop time:"].location+10]]];
                
            }
            else if([aString hasPrefix:@"data:"]){
                [self setRadValue:[[aString substringWithRange:NSMakeRange(5,6)] floatValue]];
                [self setUnits:[aString substringWithRange:NSMakeRange(10,4)]];
                if(timeUtilStop==0)[self toggleRun];

            }
        }
        @catch(NSException* e){
            NSLog(@"ex on %@\n",aString);
        }
    }
}

- (int) processHHMMSS:(NSString*)aString
{
    NSArray* timeParts = [aString componentsSeparatedByString:@":"];
    int timeLeft = 0;
    if([timeParts count]>=3){
        timeLeft = [[timeParts objectAtIndex:0] intValue]*3600 +
        [[timeParts objectAtIndex:1] intValue]*60 +
        [[timeParts objectAtIndex:2] intValue];
    }
    return timeLeft;
}
@end
