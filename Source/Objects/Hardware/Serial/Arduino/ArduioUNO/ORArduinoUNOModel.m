//--------------------------------------------------------
// ORArduinoUNOModel
// Created by Mark  A. Howe on Wed 10/17/2012
// Code partially generated by the OrcaCodeWizard. Written by Mark A. Howe.
// Copyright (c) 2012 University of North Carolina. All rights reserved.
//-----------------------------------------------------------
//This program was prepared for the Regents of the University of 
//North Carolina sponsored in part by the United States 
//Department of Energy (DOE) under Grant #DE-FG02-97ER41020. 
//The University has certain rights in the program pursuant to 
//the contract and the program should not be copied or distributed 
//outside your organization.  The DOE and the University of 
//North Carolina reserve all rights in the program. Neither the authors,
//University of North Carolina, or U.S. Government make any warranty, 
//express or implied, or assume any liability or responsibility  
//for the use of this software.
//-------------------------------------------------------------

#pragma mark •••Imported Files

#import "ORArduinoUNOModel.h"
#import "ORSerialPortAdditions.h"

#pragma mark •••External Strings
NSString* ORArduinoUNOLock					= @"ORArduinoUNOLock";
NSString* ORArduinoUNOModelPollTimeChanged	= @"ORArduinoUNOModelPollTimeChanged";
NSString* ORArduinoUNOModelAdcChanged		= @"ORArduinoUNOModelAdcChanged";
NSString* ORArduinoUNOPinTypeChanged		= @"ORArduinoUNOPinTypeChanged";
NSString* ORArduinoUNOPwmChanged			= @"ORArduinoUNOPwmChanged";
NSString* ORArduinoUNOPinValueOutChanged	= @"ORArduinoUNOPinValueOutChanged";
NSString* ORArduinoUNOPinValueInChanged		= @"ORArduinoUNOPinValueInChanged";
NSString* ORArduinoUNOPinNameChanged	= @"ORArduinoUNOPinNameChanged";

@interface ORArduinoUNOModel (private)
- (void)	clearDelay;
- (void)	processOneCommandFromQueue;
- (void)	enqueCmdString:(NSString*)aString;
- (void)	processReceivedString:(NSString*)aCommand;
- (void)	pollHardware;
@end

@implementation ORArduinoUNOModel
- (id) init
{
	self = [super init];
	return self;
}

- (void) dealloc
{
	int i;
	for(i=0;i<kNumArduinoUNOPins;i++)	[pinName[i] release];
	[inComingData release];
	[super dealloc];
}

- (void) wakeUp
{
	if(pollTime)[self pollHardware];
	[super wakeUp];
}

- (void) sleep
{
    [NSObject cancelPreviousPerformRequestsWithTarget:self];
    [super sleep];
}

- (void) setUpImage
{
	[self setImage:[NSImage imageNamed:@"ArduinoUNO.tif"]];
}

- (void) makeMainController
{
	[self linkToController:@"ORArduinoUNOController"];
}

#pragma mark •••Accessors
- (NSString*) pinName:(int)i
{
	if(i>=0 && i<kNumArduinoUNOPins){
		if([pinName[i] length])return pinName[i];
		else return [NSString stringWithFormat:@"Chan %d",i];
	}
	else return @"";
}

- (void) setPin:(int)i name:(NSString*)aName
{
	if(i>=0 && i<kNumArduinoUNOPins){
		[[[self undoManager] prepareWithInvocationTarget:self] setPin:i name:pinName[i]];
		
		[pinName[i] autorelease];
		pinName[i] = [aName copy]; 
		
		NSMutableDictionary* userInfo = [NSMutableDictionary dictionary];
		[userInfo setObject:[NSNumber numberWithInt:i] forKey: @"Pin"];
		
		[[NSNotificationCenter defaultCenter] postNotificationName:ORArduinoUNOPinNameChanged object:self userInfo:userInfo];
		
	}
}

- (unsigned char) pwm:(unsigned short)aPin
{
	if(aPin<kNumArduinoUNOPins)return pwm[aPin];
	else return 0;
}

- (void) setPin:(unsigned short)aPin pwm:(unsigned char)aValue
{
	if(aPin<kNumArduinoUNOPins){
		if(pinType[aPin] == kArduinoPWM){
			switch(aPin){
					//only these pins can be PWM
				case 1:
				case 3:
				case 4:
				case 7:
				case 8:
				case 9:
					[[[self undoManager] prepareWithInvocationTarget:self] setPin:aPin pwm:pwm[aPin]];
					pwm[aPin] = aValue;
					NSDictionary* userInfo = [NSDictionary dictionaryWithObject:[NSNumber numberWithInt:aPin] forKey:@"Pin"];
					[[NSNotificationCenter defaultCenter] postNotificationName:ORArduinoUNOPwmChanged object:self userInfo:userInfo];
					break;
			}
		}
	}
}

- (int) pinType:(unsigned short)aPin
{
	if(aPin<kNumArduinoUNOPins)return pinType[aPin];
	else return 0;
}

- (void) setPin:(unsigned short)aPin type:(unsigned short)aType
{
	if(aPin<kNumArduinoUNOPins){
		[[[self undoManager] prepareWithInvocationTarget:self] setPin:aPin type:pinType[aPin]];
		if(aType == kArduinoPWM){
			switch(aPin){
				//only these pins can be PWM
				case 1:
				case 3:
				case 4:
				case 7:
				case 8:
				case 9:
					pinType[aPin] = kArduinoPWM;
				break;
			}
		}
		else pinType[aPin] = aType;
		
		NSDictionary* userInfo = [NSDictionary dictionaryWithObject:[NSNumber numberWithInt:aPin] forKey:@"Pin"];
		[[NSNotificationCenter defaultCenter] postNotificationName:ORArduinoUNOPinTypeChanged object:self userInfo:userInfo];
	}
}

- (BOOL) pinValueOut:(unsigned short)aPin;
{
	if(aPin<kNumArduinoUNOPins) return pinValueOut[aPin];
	else return NO;
}

- (void) setPinValueOut:(unsigned short)aPin value:(BOOL)aValue
{
	@synchronized(self){
		if(aPin<kNumArduinoUNOPins){
			[[[self undoManager] prepareWithInvocationTarget:self] setPinValueOut:aPin value:pinValueOut[aPin]];
			pinValueOut[aPin] = aValue;
			NSDictionary* userInfo = [NSDictionary dictionaryWithObject:[NSNumber numberWithInt:aPin] forKey:@"Pin"];
			[[NSNotificationCenter defaultCenter] postNotificationOnMainThreadWithName:ORArduinoUNOPinValueOutChanged object:self userInfo:userInfo];
		}
	}
}

- (BOOL) pinValueIn:(unsigned short)aPin;
{
	if(aPin<kNumArduinoUNOPins) return pinValueIn[aPin];
	else return NO;
}

- (void) setPinValueIn:(unsigned short)aPin value:(BOOL)aValue
{
	@synchronized(self){
		if(aPin<kNumArduinoUNOPins){
			[[[self undoManager] prepareWithInvocationTarget:self] setPinValueIn:aPin value:pinValueIn[aPin]];
			pinValueIn[aPin] = aValue;
			NSDictionary* userInfo = [NSDictionary dictionaryWithObject:[NSNumber numberWithInt:aPin] forKey:@"Pin"];
			[[NSNotificationCenter defaultCenter] postNotificationOnMainThreadWithName:ORArduinoUNOPinValueInChanged object:self userInfo:userInfo];
		}
	}
}

- (float)  adc:(unsigned short)aChan
{
	if(aChan<kNumArduinoUNOAdcChannels)return adc[aChan];
	else return 0;
}

- (void) setAdc:(unsigned short)aChan withValue:(float)aValue
{
	if(aChan<kNumArduinoUNOAdcChannels){
		adc[aChan] = aValue;
		NSDictionary* userInfo = [NSDictionary dictionaryWithObject:[NSNumber numberWithInt:aChan] forKey:@"Channel"];
		[[NSNotificationCenter defaultCenter] postNotificationName:ORArduinoUNOModelAdcChanged object:self userInfo:userInfo];
	}		
}

- (int) pollTime
{
    return pollTime;
}

- (void) setPollTime:(int)aPollTime
{
    [[[self undoManager] prepareWithInvocationTarget:self] setPollTime:pollTime];
    pollTime = aPollTime;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORArduinoUNOModelPollTimeChanged object:self];
	
	if(pollTime){
		[self performSelector:@selector(pollHardware) withObject:nil afterDelay:.2];
	}
	else {
		[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(pollHardware) object:nil];
	}
}

- (void) setUpPort
{
	[serialPort setSpeed:57600];
	[serialPort setParityNone];
	[serialPort setStopBits2:NO];
	[serialPort setDataBits:8];
}

- (void) firstActionAfterOpeningPort
{
}

#pragma mark •••Archival
- (id) initWithCoder:(NSCoder*)decoder
{
	self = [super initWithCoder:decoder];
	[[self undoManager] disableUndoRegistration];
	[self setPollTime:		[decoder decodeIntForKey:	@"pollTime"]];

	int i;
	for(i=0;i<kNumArduinoUNOPins;i++) {
		
		NSString* aName = [decoder decodeObjectForKey:[NSString stringWithFormat:@"PinName%d",i]];
		if(aName)[self setPin:i name:aName];
		else	 [self setPin:i name:[NSString stringWithFormat:@"Pin %2d",i]];
		
		[self setPinValueOut:i value:[decoder decodeIntForKey:[NSString stringWithFormat:@"PinValueOut%d",i]]];

	}
	
	[[self undoManager] enableUndoRegistration];
	
	return self;
}

- (void) encodeWithCoder:(NSCoder*)encoder
{
    [super encodeWithCoder:encoder];
	int i;
	for(i=0;i<kNumArduinoUNOPins;i++) {
		[encoder encodeObject:pinName[i] forKey:[NSString stringWithFormat:@"pinName%d",i]];
		[encoder encodeInt:pinValueOut[i] forKey:[NSString stringWithFormat:@"pinValueOut%d",i]];
	}
	[encoder encodeInt:pollTime			forKey: @"pollTime"];
}

#pragma mark •••HW Methods
- (void) readAdcValues
{
	[self enqueCmdString:@"r a"];
}

- (void) readPins
{
	[self enqueCmdString:@"r d"];
}

- (void) updateAll
{
	[self readAdcValues];
	[self readPins];
}

- (void) initHardware
{
	int i;
	for(i=0;i<kNumArduinoUNOPins;i++){
		if(pinType[i] == kArduinoOutput){
			NSString* cmd = [NSString stringWithFormat:@"w d %d %d",i+2,pinValueOut[i]];
			[self enqueCmdString:cmd];
		}
	}
	for(i=0;i<kNumArduinoUNOPins;i++){
		if(pinType[i] == kArduinoPWM){
			NSString* cmd = [NSString stringWithFormat:@"w a %d %d",i+2,pwm[i]];
			[self enqueCmdString:cmd];
		}
	}
	
	//[self readPins];
}

#pragma mark •••Commands

- (void) dataReceived:(NSNotification*)note
{	
    if([[note userInfo] objectForKey:@"serialPort"] == serialPort){
		if(!inComingData)inComingData = [[NSMutableData data] retain];
		[inComingData appendData:[[note userInfo] objectForKey:@"data"]];
		
		char* p = (char*)[inComingData bytes];
		int i;
		int numCharsProcessed=0;
		NSMutableData* cmd =  [NSMutableData dataWithCapacity:64];
		for(i=0;i<[inComingData length];i++){
			[cmd appendBytes:p length:1];
			if(*p == '\r'){
				NSString* s = [[[NSString alloc] initWithData:cmd encoding:NSASCIIStringEncoding] autorelease];
				numCharsProcessed += [cmd length];
				[cmd setLength:0];
				[self processReceivedString:s];
			}
			p++;
		}
		if(numCharsProcessed){
			[inComingData replaceBytesInRange:NSMakeRange(0,numCharsProcessed) withBytes:nil length:0];
		}
	}
}



#pragma mark •••Bit Processing Protocol
- (void) processIsStarting { }
- (void) processIsStopping { }
- (void) startProcessCycle { }
- (void) endProcessCycle   { }

- (NSString*) identifier
{
	NSString* s;
 	@synchronized(self){
		s= [NSString stringWithFormat:@"ArduinoUNO,%lu",[self uniqueIdNumber]];
	}
	return s;
}

- (NSString*) processingTitle
{
	NSString* s;
 	@synchronized(self){
		s= [self identifier];
	}
	return s;
}

- (BOOL) processValue:(int)channel
{
	BOOL theValue = 0;
	@synchronized(self){
		switch(channel){
		}
	}
	return theValue;
}

- (void) setProcessOutput:(int)channel value:(int)value { }



@end

@implementation ORArduinoUNOModel (private)
- (void) clearDelay
{
	delay = NO;
	[self processOneCommandFromQueue];
}
- (void) processOneCommandFromQueue
{
    if(delay) return;
	
	NSString* cmdString = [self nextCmd];
	if(cmdString){
		if([cmdString isEqualToString:@"++Delay"]){
			delay = YES;
			[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(clearDelay) object:nil];
			[self performSelector:@selector(clearDelay) withObject:nil afterDelay:.2];
		}
		else {
            [self setLastRequest:cmdString];
            [serialPort writeDataInBackground:[cmdString dataUsingEncoding:NSASCIIStringEncoding]];
			[self startTimeout:3];
        }
	}
}

- (void) enqueCmdString:(NSString*)aString
{
	if([aString rangeOfString:@"\r"].location == NSNotFound)aString = [aString stringByAppendingString:@"\r"];
	//do more error checking here: make sure command is valide
	
	[self enqueueCmd:aString];
	//[self enqueueCmd:@"++Delay"]; //uncomment if delay is needed.
	if(!lastRequest)[self processOneCommandFromQueue];
}

- (void) processReceivedString:(NSString*)aCommand
{
	[self cancelTimeout];
	[self setIsValid:YES];
	aCommand = [[[aCommand removeNLandCRs] trimSpacesFromEnds] removeExtraSpaces];
	NSArray* parts = [aCommand componentsSeparatedByString:@" "];
	if([parts count] >= 1){
		if([[parts objectAtIndex:0] isEqualToString:@"a"]){
			if([parts count] >= kNumArduinoUNOAdcChannels+1){
				int i;
				for(i=0;i<kNumArduinoUNOAdcChannels;i++){
					float adcValue = [[parts objectAtIndex:1+i] floatValue] * 5.0/1023.;
					[self setAdc:i withValue:adcValue];
				}
			}
		}
		else if([[parts objectAtIndex:0] isEqualToString:@"d"]){
			if([parts count] >= kNumArduinoUNOAdcChannels+1){
				int i;
				for(i=0;i<kNumArduinoUNOPins;i++){
					int pinValue = [[parts objectAtIndex:1+i] intValue];
					[self setPinValueIn:i value:pinValue];
				}
			}
		}

		if(lastRequest){
			[self setLastRequest:nil];			 //clear the last request
			[self processOneCommandFromQueue];	 //do the next command in the queue
		}
	}
}

- (void) pollHardware
{
	[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(pollHardware) object:nil];
	[self updateAll];
	float nextTime = pollTime;
	if(nextTime == 9999)nextTime = .03;
	[self performSelector:@selector(pollHardware) withObject:nil afterDelay:nextTime];
}
@end