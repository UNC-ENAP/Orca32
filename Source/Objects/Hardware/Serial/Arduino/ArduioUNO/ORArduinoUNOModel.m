//--------------------------------------------------------
// ORArduinoUNOModel
// Created by Mark  A. Howe on Wed 10/17/2012
// Code partially generated by the OrcaCodeWizard. Written by Mark A. Howe.
// Copyright (c) 2012 University of North Carolina. All rights reserved.
//-----------------------------------------------------------
//This program was prepared for the Regents of the University of 
//North Carolina sponsored in part by the United States 
//Department of Energy (DOE) under Grant #DE-FG02-97ER41020. 
//The University has certain rights in the program pursuant to 
//the contract and the program should not be copied or distributed 
//outside your organization.  The DOE and the University of 
//North Carolina reserve all rights in the program. Neither the authors,
//University of North Carolina, or U.S. Government make any warranty, 
//express or implied, or assume any liability or responsibility  
//for the use of this software.
//-------------------------------------------------------------

#pragma mark •••Imported Files

#import "ORArduinoUNOModel.h"
#import "ORSerialPortAdditions.h"

#pragma mark •••External Strings
NSString* ORArduinoUNOLock					= @"ORArduinoUNOLock";
NSString* ORArduinoUNOModelPollTimeChanged	= @"ORArduinoUNOModelPollTimeChanged";
NSString* ORArduinoUNOModelAdcChanged		= @"ORArduinoUNOModelAdcChanged";

@interface ORArduinoUNOModel (private)
- (void)	clearDelay;
- (void)	processOneCommandFromQueue;
- (void)	enqueCmdString:(NSString*)aString;
- (void)	processReceivedString:(NSString*)aCommand;
- (void)	pollHardware;
@end

@implementation ORArduinoUNOModel
- (id) init
{
	self = [super init];
	return self;
}

- (void) dealloc
{
	[inComingData release];
	[super dealloc];
}

- (void) wakeUp
{
	if(pollTime)[self pollHardware];
	[super wakeUp];
}

- (void) sleep
{
    [NSObject cancelPreviousPerformRequestsWithTarget:self];
    [super sleep];
}

- (void) setUpImage
{
	[self setImage:[NSImage imageNamed:@"ArduinoUNO.tif"]];
}

- (void) makeMainController
{
	[self linkToController:@"ORArduinoUNOController"];
}

#pragma mark •••Accessors
- (int)  adc:(unsigned short)aChan
{
	if(aChan<kNumArduinoUNOAdcChannels)return adc[aChan];
	else return 0;
}

- (void) setAdc:(unsigned short)aChan withValue:(int)aValue
{
	if(aChan<kNumArduinoUNOAdcChannels){
		adc[aChan] = aValue;
		NSDictionary* userInfo = [NSDictionary dictionaryWithObject:[NSNumber numberWithInt:aChan] forKey:@"Channel"];
		[[NSNotificationCenter defaultCenter] postNotificationName:ORArduinoUNOModelAdcChanged object:self userInfo:userInfo];
	}		
}

- (int) pollTime
{
    return pollTime;
}

- (void) setPollTime:(int)aPollTime
{
    [[[self undoManager] prepareWithInvocationTarget:self] setPollTime:pollTime];
    pollTime = aPollTime;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORArduinoUNOModelPollTimeChanged object:self];
	
	if(pollTime){
		[self performSelector:@selector(pollHardware) withObject:nil afterDelay:pollTime];
	}
	else {
		[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(pollHardware) object:nil];
	}
}

- (void) setUpPort
{
	[serialPort setSpeed:9600];
	[serialPort setParityNone];
	[serialPort setStopBits2:NO];
	[serialPort setDataBits:8];
}

- (void) firstActionAfterOpeningPort
{
}

#pragma mark •••Archival
- (id) initWithCoder:(NSCoder*)decoder
{
	self = [super initWithCoder:decoder];
	[[self undoManager] disableUndoRegistration];
	[self setPollTime:		[decoder decodeIntForKey:	@"pollTime"]];
	[[self undoManager] enableUndoRegistration];
	
	return self;
}

- (void) encodeWithCoder:(NSCoder*)encoder
{
    [super encodeWithCoder:encoder];
    [encoder encodeInt:pollTime			forKey: @"pollTime"];
}

#pragma mark •••HW Methods
- (void) readAdcValues
{
	int i;
	for(i=0;i<kNumArduinoUNOAdcChannels;i++){
		[self readAdcValue:i];
	}
}
- (void) readAdcValue:(unsigned int)aChannel
{
	NSString* aCmd = [NSString stringWithFormat:@"001%03d",aChannel];
	[self enqueueCmd:aCmd];
}


- (void) updateAll
{
}

#pragma mark •••Commands

- (void) dataReceived:(NSNotification*)note
{
	if(!lastRequest)return;
	
    if([[note userInfo] objectForKey:@"serialPort"] == serialPort){
		if(!inComingData)inComingData = [[NSMutableData data] retain];
		[inComingData appendData:[[note userInfo] objectForKey:@"data"]];
		
		char* p = (char*)[inComingData bytes];
		int i;
		int numCharsProcessed=0;
		NSMutableData* cmd =  [NSMutableData dataWithCapacity:64];
		for(i=0;i<[inComingData length];i++){
			[cmd appendBytes:p length:1];
			if(*p == '\r'){
				NSString* s = [[[NSString alloc] initWithData:cmd encoding:NSASCIIStringEncoding] autorelease];
				numCharsProcessed += [cmd length];
				[cmd setLength:0];
				//NSLog(@"received: %@\n",s);
				[self processReceivedString:s];
			}
			p++;
		}
		if(numCharsProcessed){
			[inComingData replaceBytesInRange:NSMakeRange(0,numCharsProcessed) withBytes:nil length:0];
		}
	}
}



#pragma mark •••Bit Processing Protocol
- (void) processIsStarting { }
- (void) processIsStopping { }
- (void) startProcessCycle { }
- (void) endProcessCycle   { }

- (NSString*) identifier
{
	NSString* s;
 	@synchronized(self){
		s= [NSString stringWithFormat:@"ArduinoUNO,%lu",[self uniqueIdNumber]];
	}
	return s;
}

- (NSString*) processingTitle
{
	NSString* s;
 	@synchronized(self){
		s= [self identifier];
	}
	return s;
}

- (BOOL) processValue:(int)channel
{
	BOOL theValue = 0;
	@synchronized(self){
		switch(channel){
		}
	}
	return theValue;
}

- (void) setProcessOutput:(int)channel value:(int)value { }



@end

@implementation ORArduinoUNOModel (private)
- (void) clearDelay
{
	delay = NO;
	[self processOneCommandFromQueue];
}
- (void) processOneCommandFromQueue
{
    if(delay) return;
	
	NSString* cmdString = [self nextCmd];
	if(cmdString){
		if([cmdString isEqualToString:@"++Delay"]){
			delay = YES;
			[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(clearDelay) object:nil];
			[self performSelector:@selector(clearDelay) withObject:nil afterDelay:.2];
		}
		else {
            [self setLastRequest:cmdString];
            [serialPort writeDataInBackground:[cmdString dataUsingEncoding:NSASCIIStringEncoding]];
			[self startTimeout:3];
        }
	}
}

- (void) updateAll
{
}

- (void) enqueCmdString:(NSString*)aString
{
	if([aString rangeOfString:@"\r"].location == NSNotFound)aString = [aString stringByAppendingString:@"\r"];
	//do more error checking here: make sure command is valide
	
	[self enqueueCmd:aString];
	//[self enqueueCmd:@"++Delay"]; //uncomment if delay is needed.
	if(!lastRequest)[self processOneCommandFromQueue];
}

- (void) processReceivedString:(NSString*)aCommand
{
	[self cancelTimeout];
	[self setIsValid:YES];
	int receivedParam = [[aCommand substringWithRange:NSMakeRange(0,3)] intValue];			//<<<---depends on cmd format
	switch (receivedParam) {
			
		case 001:  //adc read format: 001 channel value
		{
			unsigned int channel = [[aCommand substringWithRange:NSMakeRange(3,3)] intValue];
			if(channel<kNumArduinoUNOAdcChannels){
				unsigned int aValue = [[aCommand substringWithRange:NSMakeRange(6,3)] intValue];
				[self setAdc:channel withValue:aValue];
			}
		}
		break;
			
		default: break;
	}
	
	if(lastRequest){
		//if the param number matches the last cmd sent, then assume a match and remove the timeout
		int lastParam	  = [[lastRequest    substringWithRange:NSMakeRange(0,3)] intValue]; //<<<---depends on cmd format
		if(receivedParam == lastParam){
			[self setLastRequest:nil];			 //clear the last request
			[self processOneCommandFromQueue];	 //do the next command in the queue
		}
	}
}

- (void) pollHardware
{
	[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(pollHardware) object:nil];
	[self updateAll];
	[self performSelector:@selector(pollHardware) withObject:nil afterDelay:pollTime];
}
@end