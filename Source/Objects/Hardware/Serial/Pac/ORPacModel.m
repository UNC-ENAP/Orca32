//--------------------------------------------------------
// ORPacModel
// Created by Mark  A. Howe on Tue Jan 6, 2009
// Code partially generated by the OrcaCodeWizard. Written by Mark A. Howe.
// Copyright (c) 2005 CENPA, University of Washington. All rights reserved.
//-----------------------------------------------------------
//This program was prepared for the Regents of the University of 
//Washington at the Center for Experimental Nuclear Physics and 
//Astrophysics (CENPA) sponsored in part by the United States 
//Department of Energy (DOE) under Grant #DE-FG02-97ER41020. 
//The University has certain rights in the program pursuant to 
//the contract and the program should not be copied or distributed 
//outside your organization.  The DOE and the University of 
//Washington reserve all rights in the program. Neither the authors,
//University of Washington, or U.S. Government make any warranty, 
//express or implied, or assume any liability or responsibility 
//for the use of this software.
//-------------------------------------------------------------

#pragma mark •••Imported Files

#import "ORPacModel.h"
#import "ORSerialPort.h"
#import "ORSerialPortAdditions.h"
#import "ORSerialPortList.h"
#import "ORDataTypeAssigner.h"
#import "ORDataPacket.h"
#import "ORTimeRate.h"

#pragma mark •••External Strings
NSString* ORPacModelShipAdcsChanged		= @"ORPacModelShipAdcsChanged";
NSString* ORPacModelPollTimeChanged		= @"ORPacModelPollTimeChanged";
NSString* ORPacModelSerialPortChanged	= @"ORPacModelSerialPortChanged";
NSString* ORPacModelPortNameChanged		= @"ORPacModelPortNameChanged";
NSString* ORPacModelPortStateChanged	= @"ORPacModelPortStateChanged";
NSString* ORPacModelAdcChanged			= @"ORPacModelAdcChanged";
NSString* ORPacModelPortDMaskChanged	= @"ORPacModelPortDMaskChanged";
NSString* ORPacModelDacChanged			= @"ORPacModelDacChanged";
NSString* ORPacLock						= @"ORPacLock";

@interface ORPacModel (private)
- (void) runStarted:(NSNotification*)aNote;
- (void) runStopped:(NSNotification*)aNote;
- (void) timeout;
- (void) processOneCommandFromQueue;
@end

@implementation ORPacModel
- (id) init
{
	self = [super init];
    [self registerNotificationObservers];
	return self;
}

- (void) dealloc
{
    [[NSNotificationCenter defaultCenter] removeObserver:self];
    [NSObject cancelPreviousPerformRequestsWithTarget:self];
    [buffer release];
	[cmdQueue release];
	[lastRequest release];
    [portName release];
	[inComingData release];
    if([serialPort isOpen]){
        [serialPort close];
    }
    [serialPort release];
	int i;
	for(i=0;i<8;i++){
		[timeRates[i] release];
	}

	[super dealloc];
}

- (void) setUpImage
{
	[self setImage:[NSImage imageNamed:@"Pac.tif"]];
}

- (void) makeMainController
{
	[self linkToController:@"ORPacController"];
}

- (void) registerNotificationObservers
{
	NSNotificationCenter* notifyCenter = [NSNotificationCenter defaultCenter];

    [notifyCenter addObserver : self
                     selector : @selector(dataReceived:)
                         name : ORSerialPortDataReceived
                       object : nil];

    [notifyCenter addObserver: self
                     selector: @selector(runStarted:)
                         name: ORRunStartedNotification
                       object: nil];
    
    [notifyCenter addObserver: self
                     selector: @selector(runStopped:)
                         name: ORRunStoppedNotification
                       object: nil];

}

- (void) shipAdcValues
{
    if([[ORGlobal sharedGlobal] runInProgress]){
		
		unsigned long data[18];
		data[0] = dataId | 18;
		data[1] = ([self uniqueIdNumber]&0xfff);
				
		int index = 2;
		int i;
		for(i=0;i<8;i++){
			data[index++] = adc[i];
			data[index++] = timeMeasured[i];
		}
		[[NSNotificationCenter defaultCenter] postNotificationName:ORQueueRecordForShippingNotification 
															object:[NSData dataWithBytes:&data length:sizeof(long)*18]];
	}
}


#pragma mark •••Accessors

- (ORTimeRate*)timeRate:(int)index
{
	return timeRates[index];
}

- (BOOL) shipAdcs
{
    return shipAdcs;
}

- (void) setShipAdcs:(BOOL)aShipAdcs
{
    [[[self undoManager] prepareWithInvocationTarget:self] setShipAdcs:shipAdcs];
    
    shipAdcs = aShipAdcs;

    [[NSNotificationCenter defaultCenter] postNotificationName:ORPacModelShipAdcsChanged object:self];
}

- (int) pollTime
{
    return pollTime;
}

- (void) setPollTime:(int)aPollTime
{
    [[[self undoManager] prepareWithInvocationTarget:self] setPollTime:pollTime];
    pollTime = aPollTime;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORPacModelPollTimeChanged object:self];

	if(pollTime){
		[self performSelector:@selector(pollAdcs) withObject:nil afterDelay:2];
	}
	else {
		[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(pollAdcs) object:nil];
	}
}

- (void) pollAdcs
{
	[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(pollAdcs) object:nil];
	[self readAdcs];
	
	[self performSelector:@selector(pollAdcs) withObject:nil afterDelay:pollTime];
}

- (unsigned short) adc:(int)index
{
	if(index>=0 && index<8)return adc[index];
	else return 0.0;
}

- (unsigned long) timeMeasured:(int)index
{
	if(index>=0 && index<8)return timeMeasured[index];
	else return 0;
}

- (void) setAdc:(int)index value:(unsigned short)aValue;
{
	if(index>=0 && index<8){
		adc[index] = aValue;
		//get the time(UT!)
		time_t	theTime;
		time(&theTime);
		struct tm* theTimeGMTAsStruct = gmtime(&theTime);
		timeMeasured[index] = mktime(theTimeGMTAsStruct);

		[[NSNotificationCenter defaultCenter] postNotificationName:ORPacModelAdcChanged 
															object:self 
														userInfo:[NSDictionary dictionaryWithObject:[NSNumber numberWithInt:index] forKey:@"Index"]];

		if(timeRates[index] == nil) timeRates[index] = [[ORTimeRate alloc] init];
		[timeRates[index] addDataToTimeAverage:aValue];

	}
}

- (unsigned short) dac:(int)index
{
	return dac[index];
}

- (void) setDac:(int)index value:(unsigned short)aValue
{
    [[[self undoManager] prepareWithInvocationTarget:self] setDac:index value:dac[index]];
	dac[index] = aValue;
	NSDictionary* chanInfo = [NSDictionary dictionaryWithObject:[NSNumber numberWithInt:index] forKey:@"Index"];
    [[NSNotificationCenter defaultCenter] postNotificationName:ORPacModelDacChanged object:self userInfo:chanInfo];
}


- (NSData*) lastRequest
{
	return lastRequest;
}

- (void) setLastRequest:(NSData*)aRequest
{
	[aRequest retain];
	[lastRequest release];
	lastRequest = aRequest;    
}

- (BOOL) portWasOpen
{
    return portWasOpen;
}

- (void) setPortWasOpen:(BOOL)aPortWasOpen
{
    portWasOpen = aPortWasOpen;
}

- (NSString*) portName
{
    return portName;
}

- (void) setPortName:(NSString*)aPortName
{
    [[[self undoManager] prepareWithInvocationTarget:self] setPortName:portName];
    
    if(![aPortName isEqualToString:portName]){
        [portName autorelease];
        portName = [aPortName copy];    

        BOOL valid = NO;
        NSEnumerator *enumerator = [ORSerialPortList portEnumerator];
        ORSerialPort *aPort;
        while (aPort = [enumerator nextObject]) {
            if([portName isEqualToString:[aPort name]]){
                [self setSerialPort:aPort];
                if(portWasOpen){
                    [self openPort:YES];
                 }
                valid = YES;
                break;
            }
        } 
        if(!valid){
            [self setSerialPort:nil];
        }       
    }

    [[NSNotificationCenter defaultCenter] postNotificationName:ORPacModelPortNameChanged object:self];
}

- (ORSerialPort*) serialPort
{
    return serialPort;
}

- (void) setSerialPort:(ORSerialPort*)aSerialPort
{
    [aSerialPort retain];
    [serialPort release];
    serialPort = aSerialPort;

    [[NSNotificationCenter defaultCenter] postNotificationName:ORPacModelSerialPortChanged object:self];
}

- (void) openPort:(BOOL)state
{
    if(state) {
		[serialPort setSpeed:9600];
		[serialPort setParityOdd];
		[serialPort setStopBits2:1];
		[serialPort setDataBits:7];
        [serialPort open];
    }
    else      [serialPort close];
    portWasOpen = [serialPort isOpen];
    [[NSNotificationCenter defaultCenter] postNotificationName:ORPacModelPortStateChanged object:self];
    
}

- (void) setPortDMask:(unsigned char)aMask
{
	[[[self undoManager] prepareWithInvocationTarget:self] setPortDMask:portDMask];
	portDMask	 = aMask;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORPacModelPortDMaskChanged object:self];
}

- (BOOL) portDBit:(int)i
{
	return (portDMask & (1<<i)) != 0;
}

- (void) writePortD
{
	[self enqueWritePortD];
}

- (void) setLcmEna
{
	[self enqueSetLcmEna:YES];
}

- (void) clrLcmEna
{
	[self enqueSetLcmEna:NO];
}

#pragma mark •••Archival
- (id) initWithCoder:(NSCoder*)decoder
{
	self = [super initWithCoder:decoder];
	[[self undoManager] disableUndoRegistration];
	[self setShipAdcs:	[decoder decodeBoolForKey:		 @"shipAdcs"]];
	[self setPollTime:		[decoder decodeIntForKey:	 @"pollTime"]];
	[self setPortWasOpen:	[decoder decodeBoolForKey:	 @"portWasOpen"]];
    [self setPortName:		[decoder decodeObjectForKey: @"portName"]];
	[[self undoManager] enableUndoRegistration];
	int i;
	for(i=0;i<8;i++){
		timeRates[i] = [[ORTimeRate alloc] init];
	}
    [self registerNotificationObservers];

	return self;
}
- (void) encodeWithCoder:(NSCoder*)encoder
{
    [super encodeWithCoder:encoder];
    [encoder encodeBool:shipAdcs		forKey: @"shipAdcs"];
    [encoder encodeInt: pollTime		forKey: @"pollTime"];
    [encoder encodeBool:portWasOpen		forKey: @"portWasOpen"];
    [encoder encodeObject:portName		forKey: @"portName"];
}

#pragma mark ••• Commands

- (void) enqueSetLcmEna:(BOOL)state
{
    if([serialPort isOpen]){ 
		
		if(!cmdQueue)cmdQueue = [[NSMutableArray array] retain];
		
		NSMutableData* cmd = [NSMutableData data];
		char theCommand = kPacLcmEnaCmd;
		[cmd appendBytes:&theCommand length:1];
		char stateWord = (state?kPacLcmEnaSet:kPacLcmEnaClr);
		[cmd appendBytes:&stateWord length:1];
		[cmdQueue addObject:cmd];
		
		if(!lastRequest)[self processOneCommandFromQueue];
	}
}
- (void) enqueReadADC:(int)aChannel
{
    if([serialPort isOpen]){ 
		
		if(!cmdQueue)cmdQueue = [[NSMutableArray array] retain];
		
		NSMutableData* cmd = [NSMutableData data];
		char theCommand = kPacADCmd;
		[cmd appendBytes:&theCommand length:1];
		[cmd appendBytes:&aChannel length:1];
		[cmdQueue addObject:cmd];
		
		if(!lastRequest)[self processOneCommandFromQueue];
	}
}

- (void) enqueWritePortD
{
    if([serialPort isOpen]){ 
		
		if(!cmdQueue)cmdQueue = [[NSMutableArray array] retain];
		
		NSMutableData* cmd = [NSMutableData data];
		char theCommand = kPacSelCmd;
		[cmd appendBytes:&theCommand length:1];
		[cmd appendBytes:&portDMask length:1];
		[cmdQueue addObject:cmd];
		
		if(!lastRequest)[self processOneCommandFromQueue];
	}
}


- (void) enqueWriteDac:(int)aChannel
{
    if([serialPort isOpen]){ 
		
		if(!cmdQueue)cmdQueue = [[NSMutableArray array] retain];

		NSMutableData* cmd = [NSMutableData data];
		//put in the cmd
		char theCommand = kPacRDacCmd;
		[cmd appendBytes:&theCommand length:1];
		//put in the cmd that specifies R/W
		theCommand = kPacRDacWriteOneRDac;
		[cmd appendBytes:&theCommand length:1];
		//select the channel
		[cmd appendBytes:&aChannel length:1];
		//put in the data
		char msb = dac[aChannel]>>8;
		char lsb = dac[aChannel]&0xff;
		[cmd appendBytes:&msb length:1];
		[cmd appendBytes:&lsb length:1];
		
		[cmdQueue addObject:cmd];
		
		if(!lastRequest)[self processOneCommandFromQueue];
	}
}

- (void) enqueReadDac:(int)aChannel
{
    if([serialPort isOpen]){ 
		
		if(!cmdQueue)cmdQueue = [[NSMutableArray array] retain];
		
		NSMutableData* cmd = [NSMutableData data];
		//put in the cmd
		char theCommand = kPacRDacCmd;
		[cmd appendBytes:&theCommand length:1];
		//put in the cmd that specifies R/W	
		theCommand = kPacRDacReadOneRDac;
		[cmd appendBytes:&theCommand length:1];
		//select the channel		
		[cmd appendBytes:&aChannel length:1];
				
		[cmdQueue addObject:cmd];
		
		if(!lastRequest)[self processOneCommandFromQueue];
	}
}



- (void) enqueShipCmd
{
    if([serialPort isOpen]){ 
		
		if(!cmdQueue)cmdQueue = [[NSMutableArray array] retain];
		
		NSMutableData* cmd = [NSMutableData data];
		char theCommand = kPacShipAdcs;
		[cmd appendBytes:&theCommand length:1];
		[cmdQueue addObject:cmd];
		
		if(!lastRequest)[self processOneCommandFromQueue];
	}
}

- (void) readAdcs
{
	int i;
	for(i=0;i<8;i++){
		[self enqueReadADC:i];
	}
	[self enqueShipCmd];
}

- (void) writeDacs
{
	int i;
	for(i=0;i<8;i++){
		[self enqueWriteDac:i];
	}
}

- (void) readDacs
{
	int i;
	for(i=0;i<8;i++){
		[self enqueReadDac:i];
	}
}

#pragma mark •••Data Records
- (unsigned long) dataId { return dataId; }
- (void) setDataId: (unsigned long) DataId
{
    dataId = DataId;
}
- (void) setDataIds:(id)assigner
{
    dataId       = [assigner assignDataIds:kLongForm];
}

- (void) syncDataIdsWith:(id)anotherPac
{
    [self setDataId:[anotherPac dataId]];
}

- (void) appendDataDescription:(ORDataPacket*)aDataPacket userInfo:(id)userInfo
{
    //----------------------------------------------------------------------------------------
    // first add our description to the data description
    [aDataPacket addDataDescriptionItem:[self dataRecordDescription] forKey:@"PacModel"];
}

- (NSDictionary*) dataRecordDescription
{
    NSMutableDictionary* dataDictionary = [NSMutableDictionary dictionary];
    NSDictionary* aDictionary = [NSDictionary dictionaryWithObjectsAndKeys:
        @"ORPacDecoderForAdc",				@"decoder",
        [NSNumber numberWithLong:dataId],   @"dataId",
        [NSNumber numberWithBool:NO],       @"variable",
        [NSNumber numberWithLong:8],        @"length",
        nil];
    [dataDictionary setObject:aDictionary forKey:@"Adcs"];
    
    return dataDictionary;
}

- (void) dataReceived:(NSNotification*)note
{
	BOOL done = NO;
	if(!lastRequest)return;
	
    if([[note userInfo] objectForKey:@"serialPort"] == serialPort){
		if(!inComingData)inComingData = [[NSMutableData data] retain];
        [inComingData appendData:[[note userInfo] objectForKey:@"data"]];
		
		char* theCmd = (char*)[lastRequest bytes];
		switch (theCmd[0]){
			case kPacADCmd:
				if([inComingData length] == 3) {
					unsigned char* theData	 = (unsigned char*)[inComingData bytes];
					short theChannel = theCmd[1] & 0x7;
					short msb		 = theData[0];
					short lsb		 = theData[1];
					if(theData[2] == kPacOkByte) [self setAdc:theChannel value: msb<<8 | lsb];
					else						 NSLogError(@"PAC",@"ADC !OK",nil);
					done = YES;
				}
			break;
				
			case kPacSelCmd:
				if([inComingData length] == 1) {
					unsigned char* theData	 = (unsigned char*)[inComingData bytes];
					if(theData[0] != kPacOkByte)  NSLogError(@"PAC",@"Port D !OK",nil);
					done = YES;
				}
			break;
				
			case kPacRDacCmd:
				if(theCmd[1] == kPacRDacReadOneRDac){
					if([inComingData length] == 3) {
						unsigned char* theData	 = (unsigned char*)[inComingData bytes];
						short theChannel = theCmd[1] & 0x7;
						short msb		 = theData[0];
						short lsb		 = theData[1];
						if(theData[2] == kPacOkByte) [self setDac:theChannel value: msb<<8 | lsb];
						else						 NSLogError(@"PAC",@"DAC !OK",nil);
						done = YES;
					}
				}
				else if(theCmd[1] == kPacRDacWriteOneRDac){
					if([inComingData length] == 1) {
						unsigned char* theData	 = (unsigned char*)[inComingData bytes];
						if(theData[0] != kPacOkByte) NSLogError(@"PAC",@"DAC !OK",nil);
					}
				}
			break;
				
			case kPacLcmEnaCmd:
				if([inComingData length] == 1) {
					unsigned char* theData	 = (unsigned char*)[inComingData bytes];
					if(theData[0] != kPacOkByte)  NSLogError(@"PAC",@"LCM ENA !OK",nil);
					done = YES;
				}
			break;
				
		}
		
		if(done){
			[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(timeout) object:nil];
			[self setLastRequest:nil];			 //clear the last request
			[self processOneCommandFromQueue];	 //do the next command in the queue
		}
	}
}

@end

@implementation ORPacModel (private)

- (void) runStarted:(NSNotification*)aNote
{
}

- (void) runStopped:(NSNotification*)aNote
{
}

- (void) timeout
{
	NSLogError(@"PAC",@"command timeout",nil);
	[self setLastRequest:nil];
	[self processOneCommandFromQueue];	 //do the next command in the queue
}

- (void) processOneCommandFromQueue
{
	if([cmdQueue count] == 0) return;
	NSData* cmdData = [[[cmdQueue objectAtIndex:0] retain] autorelease];
	[cmdQueue removeObjectAtIndex:0];
	unsigned char* cmd = (unsigned char*)[cmdData bytes];
	if(cmd[0] == kPacShipAdcs){
		if(shipAdcs) [self shipAdcValues];
	}
	else {
		[self setLastRequest:cmdData];
		[serialPort writeDataInBackground:cmdData];
		[self performSelector:@selector(timeout) withObject:nil afterDelay:3];
	}
}

@end