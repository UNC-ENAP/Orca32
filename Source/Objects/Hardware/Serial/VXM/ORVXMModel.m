//--------------------------------------------------------
// ORVXMModel
// Created by Mark  A. Howe on Fri Jul 22 2005
// Code partially generated by the OrcaCodeWizard. Written by Mark A. Howe.
// Copyright (c) 2005 CENPA, University of Washington. All rights reserved.
//-----------------------------------------------------------
//This program was prepared for the Regents of the University of 
//Washington at the Center for Experimental Nuclear Physics and 
//Astrophysics (CENPA) sponsored in part by the United States 
//Department of Energy (DOE) under Grant #DE-FG02-97ER41020. 
//The University has certain rights in the program pursuant to 
//the contract and the program should not be copied or distributed 
//outside your organization.  The DOE and the University of 
//Washington reserve all rights in the program. Neither the authors,
//University of Washington, or U.S. Government make any warranty, 
//express or implied, or assume any liability or responsibility 
//for the use of this software.
//-------------------------------------------------------------

#pragma mark ***Imported Files

#import "ORVXMModel.h"
#import "ORSerialPort.h"
#import "ORSerialPortList.h"
#import "ORSerialPort.h"
#import "ORSerialPortAdditions.h"
#import "ORDataTypeAssigner.h"
#import "ORDataPacket.h"

#define kMotor0 0x1
#define kMotor1 0x2

#pragma mark ***External Strings
NSString* ORVXMModelEnabledMaskChanged = @"ORVXMModelEnabledMaskChanged";
NSString* ORVXMModelConversionChanged = @"ORVXMModelConversionChanged";
NSString* ORVXMModelFullScaleChanged = @"ORVXMModelFullScaleChanged";
NSString* ORVXMModelEndEditing        = @"ORVXMModelEndEditing";
NSString* ORVXMModelMovingChanged     = @"ORVXMModelMovingChanged";
NSString* ORVXMModelPatternChanged    = @"ORVXMModelPatternChanged";
NSString* ORVXMModelDwellTimeChanged  = @"ORVXMModelDwellTimeChanged";
NSString* ORVXMModelOptionMaskChanged = @"ORVXMModelOptionMaskChanged";
NSString* ORVXMModelPatternTypeChanged= @"ORVXMModelPatternTypeChanged";
NSString* ORVXMModelCmdFileChanged    = @"ORVXMModelCmdFileChanged";
NSString* ORVXMModelGoingHomeChanged  = @"ORVXMModelGoingHomeChanged";
NSString* ORVXMModelAbsMotionChanged  = @"ORVXMModelAbsMotionChanged";
NSString* ORVXMModelCmdPositionChanged= @"ORVXMModelCmdPositionChanged";
NSString* ORVXMModelPositionChanged   = @"ORVXMModelPositionChanged";
NSString* ORVXMModelSerialPortChanged = @"ORVXMModelSerialPortChanged";
NSString* ORVXMModelPortNameChanged   = @"ORVXMModelPortNameChanged";
NSString* ORVXMModelPortStateChanged  = @"ORVXMModelPortStateChanged";

NSString* ORVXMLock = @"ORVXMLock";

@interface ORVXMModel (private)
- (void) runStarted:(NSNotification*)aNote;
- (void) runStopped:(NSNotification*)aNote;
- (void) startPattern;
- (void) stopPattern;
- (void) continuePattern;
@end

@implementation ORVXMModel
- (id) init
{
	self = [super init];
    [self registerNotificationObservers];
	return self;
}

- (void) dealloc
{
    [[NSNotificationCenter defaultCenter] removeObserver:self];
    [cmdList release];
    [cmdFile release];
    [NSObject cancelPreviousPerformRequestsWithTarget:self];
	[[NSNotificationCenter defaultCenter] removeObserver:self];
    [portName release];
    if([serialPort isOpen]){
        [serialPort close];
    }
    [serialPort release];
    [buffer release];
	[super dealloc];
}

- (void) setUpImage
{
	[self setImage:[NSImage imageNamed:@"VXM"]];
}

- (void) makeMainController
{
	[self linkToController:@"ORVXMController"];
}

- (void) registerNotificationObservers
{
	NSNotificationCenter* notifyCenter = [NSNotificationCenter defaultCenter];
	
    [notifyCenter addObserver : self
                     selector : @selector(dataReceived:)
                         name : ORSerialPortDataReceived
                       object : nil];
	
    [notifyCenter addObserver: self
                     selector: @selector(runStarted:)
                         name: ORRunStartedNotification
                       object: nil];
    
    [notifyCenter addObserver: self
                     selector: @selector(runStopped:)
                         name: ORRunStoppedNotification
                       object: nil];
	
}

- (void) dataReceived:(NSNotification*)note
{
    if([[note userInfo] objectForKey:@"serialPort"] == serialPort){
        NSString* theString = [[[[NSString alloc] initWithData:[[note userInfo] objectForKey:@"data"] 
													  encoding:NSASCIIStringEncoding] autorelease] uppercaseString];
        if(!buffer){
            buffer = [[NSMutableString string] retain];
        }
		
		//remove the 'junk'
		theString = [[theString componentsSeparatedByString:@"^"] componentsJoinedByString:@""];
		
        [buffer appendString:theString];
        do {
			//the strings echo'ed from the VXM controller should be delimited by <cr>
            NSRange lineRange = [buffer rangeOfString:@"\r"];
            if(lineRange.location!= NSNotFound){
                NSMutableString* aCmd = [[[buffer substringToIndex:lineRange.location+1] mutableCopy] autorelease];
                [buffer deleteCharactersInRange:NSMakeRange(0,lineRange.location+1)];      //take it out of the buffer
                NSScanner* scanner = [NSScanner scannerWithString:aCmd];
				if ( [self isMotorEnabled:0] && ( queryInProgress & kMotor0 ) ){
					float xValue;
					[scanner scanFloat: &xValue];
					oldXyPosition.x = xyPosition.x;
					xValue = xValue / conversion.x; //convert steps to mm
					[self setXyPosition:NSMakePoint( xValue, xyPosition.y )];
					queryInProgress ^= kMotor0;
				}
				
				if ( [self isMotorEnabled:1] && ( queryInProgress & kMotor1 ) ){
					float yValue;
					[scanner scanFloat: &yValue];
					oldXyPosition.y = xyPosition.y;
					yValue = yValue / conversion.y; //convert steps to mm
					[self setXyPosition:NSMakePoint( xyPosition.x, yValue )];
					queryInProgress ^= kMotor1;
				}
					
				if(!NSEqualPoints(oldXyPosition,xyPosition)){
					[self performSelector:@selector(queryPosition) withObject:nil afterDelay:.3];
					[self setMoving:YES];
				}
				else {
					if(goingHome){
						[serialPort writeString:@"F,N"]; //clear position regs
						[self setGoingHome:NO];
						validTrackCount = 0;
						currentTrackIndex = 0;
						[self performSelector:@selector(queryPosition) withObject:nil afterDelay:.3];
					}
					else [self setMoving:NO];
				}
			}
        } while([buffer rangeOfString:@"\r"].location!= NSNotFound);
    }
}

- (void) shipMotorState:(BOOL)running
{
    if([[ORGlobal sharedGlobal] runInProgress]){
        if([self optionSet:kXYShipPositionOption]){
            //get the time(UT!)
            time_t	ut_time;
            time(&ut_time);
            //struct tm* theTimeGMTAsStruct = gmtime(&theTime);
            //time_t ut_time = mktime(theTimeGMTAsStruct);
            
            unsigned long data[5];
            data[0] = dataId | 5;
            data[1] = ut_time;
            data[2] = (running?1:0)<<16 | ([self uniqueIdNumber]&0x0000fffff);
            
            //encode the position 
            union {
                long asLong;
                float asFloat;
            }thePosition;
            thePosition.asFloat = [self xyPosition].x;
            data[3] = thePosition.asLong;
            
            thePosition.asFloat = [self xyPosition].y;
            data[4] = thePosition.asLong;
            
            [[NSNotificationCenter defaultCenter] postNotificationName:ORQueueRecordForShippingNotification 
                                                                object:[NSData dataWithBytes:data length:sizeof(long)*5]];
        }
    }
}


#pragma mark ***Accessors

- (unsigned short) enabledMask
{
    return enabledMask;
}

- (void) setEnabledMask:(unsigned short)aEnabledMask
{
    [[[self undoManager] prepareWithInvocationTarget:self] setEnabledMask:enabledMask];
    
    enabledMask = aEnabledMask;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:ORVXMModelEnabledMaskChanged object:self];
}

- (BOOL) isMotorEnabled:(unsigned short)aMotor
{
	return (BOOL)((enabledMask>>aMotor) & 0x1);
}

- (void) enableMotor:(unsigned short)aMotor withValue:(BOOL)aState
{
	unsigned short aMask = enabledMask;
	if(aState)aMask |= (0x1<<aMotor);
	else aMask &= ~(0x1<<aMotor);
	[self setEnabledMask:aMask];
}

- (NSPoint) conversion
{
    return conversion;
}

- (void) setConversion:(NSPoint)aConversion
{
    [[[self undoManager] prepareWithInvocationTarget:self] setConversion:conversion];
    
	if(aConversion.x == 0)aConversion.x = 1;
	if(aConversion.y == 0)aConversion.y = 1;
	
    conversion = aConversion;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:ORVXMModelConversionChanged object:self];
}

- (NSPoint) fullScale
{
    return fullScale;
}

- (void) setFullScale:(NSPoint)aFullScale
{
    [[[self undoManager] prepareWithInvocationTarget:self] setFullScale:fullScale];
    
	if(aFullScale.x == 0)aFullScale.x = 100;
	if(aFullScale.y == 0)aFullScale.y = 100;
    fullScale = aFullScale;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:ORVXMModelFullScaleChanged object:self];
}


- (NSMutableArray*) cmdList
{
    return cmdList;
}

- (void) setCmdList:(NSMutableArray*)aCmdList
{
    [aCmdList retain];
    [cmdList release];
    cmdList = aCmdList;
}

- (BOOL) moving
{
    return moving;
}

- (void) setMoving:(BOOL)aMoving
{
    if(moving!=aMoving){
        [self shipMotorState:moving];
        moving = aMoving;
        [[NSNotificationCenter defaultCenter] postNotificationName:ORVXMModelMovingChanged object:self];
    }
}

- (NSPoint) delta
{
    return delta;
}

- (void) setDelta:(NSPoint)aDelta
{
    [[[self undoManager] prepareWithInvocationTarget:self] setDelta:delta];
    
    delta = aDelta;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:ORVXMModelPatternChanged object:self];
}

- (unsigned long) optionMask
{
    return optionMask;
}

- (void) setOptionMask:(unsigned long)aOptionMask
{
    [[[self undoManager] prepareWithInvocationTarget:self] setOptionMask:optionMask];
    
    optionMask = aOptionMask;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:ORVXMModelOptionMaskChanged object:self];
}
- (void) setOption:(int)anOption 
{
    long aMask = optionMask;
    aMask |= (0x1L<<anOption);
    [self setOptionMask:aMask];
}

- (void) clearOption:(int)anOption 
{
    long aMask = optionMask;
    aMask &= ~(0x1L<<anOption);
    [self setOptionMask:aMask];
}

- (BOOL) optionSet:(int)anOption 
{
    return (optionMask & (0x1L<<anOption))!=0;
}

- (int) patternType
{
    return patternType;
}

- (void) setPatternType:(int)aPatternType
{
    [[[self undoManager] prepareWithInvocationTarget:self] setPatternType:patternType];
    
    patternType = aPatternType;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:ORVXMModelPatternTypeChanged object:self];
}


- (float) dwellTime
{
    return dwellTime;
}

- (void) setDwellTime:(float)aDwellTime
{
    [[[self undoManager] prepareWithInvocationTarget:self] setDwellTime:dwellTime];
    
    dwellTime = aDwellTime;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:ORVXMModelDwellTimeChanged object:self];
}

- (NSPoint) endPoint
{
    return endPoint;
}

- (void) setEndPoint:(NSPoint)aEnd
{
    [[[self undoManager] prepareWithInvocationTarget:self] setEndPoint:endPoint];
    
    endPoint = aEnd;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:ORVXMModelPatternChanged object:self];
}

- (NSPoint) startPoint
{
    return startPoint;
}

- (void) setStartPoint:(NSPoint)aStart
{
    [[[self undoManager] prepareWithInvocationTarget:self] setStartPoint:startPoint];
    
    startPoint = aStart;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:ORVXMModelPatternChanged object:self];
}

- (NSString*) cmdFile
{
    return cmdFile;
}

- (void) setCmdFile:(NSString*)aCmdFile
{
    [[[self undoManager] prepareWithInvocationTarget:self] setCmdFile:cmdFile];
    
    [cmdFile autorelease];
    cmdFile = [aCmdFile copy];    
	
    [[NSNotificationCenter defaultCenter] postNotificationName:ORVXMModelCmdFileChanged object:self];
}

- (unsigned)currentTrackIndex
{
    return currentTrackIndex;
}

- (unsigned)validTrackCount
{
    return validTrackCount;
}

- (NSPoint) track:(unsigned)i
{
    if(i<kNumTrackPoints)return track[i];
    else return NSZeroPoint;
}


- (BOOL) goingHome
{
    return goingHome;
}

- (void) setGoingHome:(BOOL)aGoingHome
{
    goingHome = aGoingHome;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORVXMModelGoingHomeChanged object:self];
}

- (BOOL) absMotion
{
    return absMotion;
}

- (void) setAbsMotion:(BOOL)aAbsMotion
{
    [[[self undoManager] prepareWithInvocationTarget:self] setAbsMotion:absMotion];
    
    absMotion = aAbsMotion;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:ORVXMModelAbsMotionChanged object:self];
}

- (NSPoint) cmdPosition
{
    return cmdPosition;
}

- (void) setCmdPosition:(NSPoint)aCmdPosition
{
    [[[self undoManager] prepareWithInvocationTarget:self] setCmdPosition:cmdPosition];
    
    cmdPosition = aCmdPosition;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:ORVXMModelCmdPositionChanged object:self];
}


- (NSPoint) xyPosition
{
    return xyPosition;
}

- (void) setXyPosition:(NSPoint)aPosition
{
    if(!NSEqualPoints(xyPosition,aPosition)){
		
        xyPosition = aPosition;
		
        track[currentTrackIndex] = xyPosition;
        currentTrackIndex  = currentTrackIndex++;
        if(currentTrackIndex>=kNumTrackPoints)currentTrackIndex = 0;
        validTrackCount++;
        if(validTrackCount>kNumTrackPoints)validTrackCount= kNumTrackPoints;
        
        [[NSNotificationCenter defaultCenter] postNotificationName:ORVXMModelPositionChanged object:self];
    }
}

- (BOOL) portWasOpen
{
    return portWasOpen;
}

- (void) setPortWasOpen:(BOOL)aPortWasOpen
{
    portWasOpen = aPortWasOpen;
}

- (NSString*) portName
{
    return portName;
}

- (void) setPortName:(NSString*)aPortName
{
    [[[self undoManager] prepareWithInvocationTarget:self] setPortName:portName];
    
    if(![aPortName isEqualToString:portName]){
        [portName autorelease];
        portName = [aPortName copy];    
		
        BOOL valid = NO;
        NSEnumerator *enumerator = [ORSerialPortList portEnumerator];
        ORSerialPort *aPort;
        while (aPort = [enumerator nextObject]) {
            if([portName isEqualToString:[aPort name]]){
                [self setSerialPort:aPort];
                if(portWasOpen){
                    [self openPort:YES];
                    if([serialPort isOpen]){
						[self performSelector:@selector(queryPosition) withObject:nil afterDelay:.3];
                    }
                }
                valid = YES;
                break;
            }
        } 
        if(!valid){
            [self setSerialPort:nil];
        }       
    }
	
    [[NSNotificationCenter defaultCenter] postNotificationName:ORVXMModelPortNameChanged object:self];
}

- (ORSerialPort*) serialPort
{
    return serialPort;
}

- (void) setSerialPort:(ORSerialPort*)aSerialPort
{
    [aSerialPort retain];
    [serialPort release];
    serialPort = aSerialPort;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:ORVXMModelSerialPortChanged object:self];
}

- (void) openPort:(BOOL)state
{
    if(state) {
        [serialPort open];
    }
    else      [serialPort close];
    portWasOpen = [serialPort isOpen];
    [[NSNotificationCenter defaultCenter] postNotificationName:ORVXMModelPortStateChanged object:self];
    
}


#pragma mark ***Archival
- (id) initWithCoder:(NSCoder*)decoder
{
	self = [super initWithCoder:decoder];
	[[self undoManager] disableUndoRegistration];
	[self setEnabledMask:[decoder decodeIntForKey:@"ORVXMModelEnabledMask"]];
	[self setOptionMask:[decoder decodeInt32ForKey:@"ORVXMModelOptionMask"]];
	[self setPatternType:[decoder decodeIntForKey:@"ORVXMModelPatternType"]];
	[self setCmdFile:[decoder decodeObjectForKey:  @"ORVXMModelCmdFile"]];
	[self setAbsMotion:[decoder decodeBoolForKey:  @"ORVXMModelAbsMotion"]];
	[self setPortWasOpen:[decoder decodeBoolForKey:@"ORVXMModelPortWasOpen"]];
    [self setPortName:[decoder decodeObjectForKey: @"portName"]];
	
	[self setConversion:[decoder decodePointForKey:@"ORVXMModelConversion"]];
	[self setFullScale:[decoder decodePointForKey:@"ORVXMModelFullScale"]];
	[self setCmdPosition:[decoder decodePointForKey: @"ORVXMModelCmdPosition"]];
	[self setDelta:[decoder decodePointForKey:@"ORVXMModelDelta"]];
	[self setDwellTime:[decoder decodeFloatForKey:@"ORVXMModelDwellPerPoint"]];
	[self setEndPoint:[decoder decodePointForKey:@"ORVXMModelEnd"]];
	[self setStartPoint:[decoder decodePointForKey:@"ORVXMModelStart"]];
	
	[[self undoManager] enableUndoRegistration];
	
    [self registerNotificationObservers];
	
	return self;
}
- (void) encodeWithCoder:(NSCoder*)encoder
{
    [super encodeWithCoder:encoder];
    [encoder encodeInt:enabledMask forKey:@"ORVXMModelEnabledMask"];
    [encoder encodeInt32:optionMask forKey:@"ORVXMModelOptionMask"];
    [encoder encodeInt:patternType forKey:@"ORVXMModelPatternType"];
    [encoder encodeObject:cmdFile forKey:  @"ORVXMModelCmdFile"];
    [encoder encodeBool:absMotion forKey:  @"ORVXMModelAbsMotion"];
    [encoder encodeBool:portWasOpen forKey:@"ORVXMModelPortWasOpen"];
    [encoder encodeObject:portName forKey: @"portName"];
	
	
    [encoder encodePoint:conversion forKey:@"ORVXMModelConversion"];
    [encoder encodePoint:fullScale forKey:@"ORVXMModelFullScale"];
    [encoder encodePoint:cmdPosition forKey: @"ORVXMModelCmdPosition"];
    [encoder encodePoint:delta forKey:@"ORVXMModelDelta"];
    [encoder encodeFloat:dwellTime forKey:@"ORVXMModelDwellPerPoint"];
    [encoder encodePoint:endPoint forKey:@"ORVXMModelEnd"];
    [encoder encodePoint:startPoint forKey:@"ORVXMModelStart"];
	
}

#pragma mark ***Motor Commands
- (void) queryPosition
{
	[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(queryPosition) object:nil];
    if([serialPort isOpen]){
		queryInProgress = 0;
        if([self isMotorEnabled:0])
		{
			[serialPort writeString:@"E,X"];
			queryInProgress = kMotor0;
		}
        if([self isMotorEnabled:1])
		{
			[serialPort writeString:@"E,Y"];
			queryInProgress += kMotor1;
		}
    }
}
- (void) goHome
{
    if([serialPort isOpen]){
        [self setGoingHome:YES];
		NSMutableString* cmd = [NSMutableString string];
		if([self isMotorEnabled:0])[cmd appendString:@"F,I1M-0"];
		if([self isMotorEnabled:1])[cmd appendString:@"F,I2M-0"];
		if([cmd length]){
			[cmd appendString:@" R"];
			[serialPort writeString:cmd];
		}

		[self performSelector:@selector(queryPosition) withObject:nil afterDelay:.3];
    }
}

- (void) stopMotion
{
    if([serialPort isOpen]){
        [serialPort writeString:@"F,K"];
		[self performSelector:@selector(queryPosition) withObject:nil afterDelay:.3];
    }
}

- (void) go
{
    if([serialPort isOpen]){
        [self resetTrack];
        
        if(absMotion) [self moveToPoint:NSMakePoint(cmdPosition.x,cmdPosition.y)];
        else          [self move:NSMakePoint(cmdPosition.x,cmdPosition.y)];
    }
}

- (void) moveToPoint:(NSPoint)aPoint
{
    if([serialPort isOpen]){        
		NSMutableString* cmd = [NSMutableString string];
		if([self isMotorEnabled:0])[cmd appendString:[NSString stringWithFormat:@"F,C,S2M250,IA1M%d",(int)aPoint.x*conversion.x]];
		if([self isMotorEnabled:1])[cmd appendString:[NSString stringWithFormat:@"F,C,S2M250,IA2M%d",(int)aPoint.y*conversion.y]];
		if([cmd length]){
			[cmd appendString:@",R"];
			[serialPort writeString:cmd];
		}
		[self performSelector:@selector(queryPosition) withObject:nil afterDelay:.3];
    }
}

- (void) move:(NSPoint)amount
{
    if([serialPort isOpen]){        
		NSMutableString* cmd = [NSMutableString string];
		int xPos = (int)(amount.x*conversion.x);
		if([self isMotorEnabled:0])[cmd appendString:[NSString stringWithFormat:@"F,C,S2M250,I1M%d", xPos]];
		int yPos = (int)(amount.y*conversion.y);
		if([self isMotorEnabled:1])[cmd appendString:[NSString stringWithFormat:@"F,C,S2M250,I2M%d", yPos]];
		if([cmd length]){
			[cmd appendString:@",R"];
			[serialPort writeString:cmd];
		}
		[self performSelector:@selector(queryPosition) withObject:nil afterDelay:.3];
    }
}

- (void) sendCmd:(NSString*)aCmd
{
    if([serialPort isOpen]){
        [serialPort writeString:aCmd];
		[self performSelector:@selector(queryPosition) withObject:nil afterDelay:.3];
    }
}


- (void) resetTrack
{
	float xPos;
	float yPos;
	
    currentTrackIndex = 0;
    validTrackCount   = 0;
	if ([self isMotorEnabled:0]) 
	{
		xPos = -1;
	}
	else
	{
		xPos = oldXyPosition.x;
	}
	
	if ( [self isMotorEnabled:1])
	{
		yPos = -1;
	}
	else
	{
		yPos = oldXyPosition.y;
	}
    oldXyPosition = NSMakePoint( xPos, yPos);
}

- (void) runCmdFile
{
    if([serialPort isOpen]){
        [self resetTrack];
        NSData* theCmdData = [NSData dataWithContentsOfFile:[cmdFile stringByExpandingTildeInPath]];
        NSString* theCmdString = [[[NSString alloc] initWithData:theCmdData encoding:NSASCIIStringEncoding] autorelease];
        [serialPort writeString:theCmdString];
		[self performSelector:@selector(queryPosition) withObject:nil afterDelay:2.];
    }
}


#pragma mark ***Data Records
- (unsigned long) dataId { return dataId; }
- (void) setDataId: (unsigned long) DataId
{
    dataId = DataId;
}
- (void) setDataIds:(id)assigner
{
    dataId       = [assigner assignDataIds:kLongForm];
}

- (void) syncDataIdsWith:(id)anotherVXM
{
    [self setDataId:[anotherVXM dataId]];
}

- (void) appendDataDescription:(ORDataPacket*)aDataPacket userInfo:(id)userInfo
{
    //----------------------------------------------------------------------------------------
    // first add our description to the data description
    [aDataPacket addDataDescriptionItem:[self dataRecordDescription] forKey:@"VXMModel"];
}

- (NSDictionary*) dataRecordDescription
{
    NSMutableDictionary* dataDictionary = [NSMutableDictionary dictionary];
    NSDictionary* aDictionary = [NSDictionary dictionaryWithObjectsAndKeys:
        @"ORVXMDecoderForPosition",   @"decoder",
        [NSNumber numberWithLong:dataId],   @"dataId",
        [NSNumber numberWithBool:NO],       @"variable",
        [NSNumber numberWithLong:5],        @"length",
        nil];
    [dataDictionary setObject:aDictionary forKey:@"Position"];
    
    return dataDictionary;
}

@end

@implementation ORVXMModel (private)

- (void) runStarted:(NSNotification*)aNote
{
	
    [[NSNotificationCenter defaultCenter]
        postNotificationName:ORVXMModelEndEditing
                      object:self];
	
    if([self optionSet:kXYSyncWithRunOption]){
        if([serialPort isOpen]){
            [self startPattern];
        }
        else {
            [self openPort:YES];
            if([serialPort isOpen]){
                [self startPattern];
            }
            else {
                //couldn't open port...stop the run.
                NSString* reason = [NSString stringWithFormat:@"VXM %d port could not be opened",[self  uniqueIdNumber]];
                
                [[NSNotificationCenter defaultCenter]
                    postNotificationName:ORRequestRunHalt
                                  object:self
                                userInfo:[NSDictionary dictionaryWithObjectsAndKeys:reason,@"Reason",nil]];
			}
        }
    }
}

- (void) runStopped:(NSNotification*)aNote
{
    if([self optionSet:kXYSyncWithRunOption]){
        [self stopPattern];
    }
}

- (void) startPattern
{
    if([serialPort isOpen]){
        if(!cmdList)[self setCmdList:[NSMutableArray array]];
        else [cmdList removeAllObjects];
        float x,y;
        if(patternType == kXYUseFile){
            NSString* fullPath = [cmdFile stringByExpandingTildeInPath];
            if([[NSFileManager defaultManager] fileExistsAtPath:fullPath]){
                NSString* contents = [NSString stringWithContentsOfFile:fullPath encoding:NSASCIIStringEncoding error:nil];
                contents = [[contents componentsSeparatedByString:@"\r"] componentsJoinedByString:@"\n"];
                contents = [[contents componentsSeparatedByString:@"\n\n"] componentsJoinedByString:@"\n"];
                [self setCmdList:[[[contents componentsSeparatedByString:@"\n"] mutableCopy] autorelease]];
            }
        }
        else if(patternType == kXYRaster){
            for(y=startPoint.y;y<=endPoint.y;y+=delta.y){
                for(x=startPoint.x;x<=endPoint.x;x+=delta.x){
					NSMutableString* cmd = [NSMutableString string];
					if([self isMotorEnabled:0])[cmd appendString:[NSString stringWithFormat:@"F IA1M%d",(int)x*conversion.x]];
					if([self isMotorEnabled:1])[cmd appendString:[NSString stringWithFormat:@"F IA2M%d",(int)y*conversion.y]];
					if([cmd length]){
						[cmd appendString:@" R"];
						[cmdList addObject:cmd];
					}
                }
            }
        }
        else {
            int sign = -1;
            float startx = startPoint.x;
            float endx   = endPoint.x;
            for(y=startPoint.y;y<=endPoint.y;y+=delta.y){
                //toggle the direction
                if(sign == -1) sign = 1;
                else sign = -1;
                if(sign == 1){
                    for(x=startx;x<=endx;x+=delta.x){
						NSMutableString* cmd = [NSMutableString string];
						if([self isMotorEnabled:0])[cmd appendString:[NSString stringWithFormat:@"F IA1M%d",(int)x*conversion.x]];
						if([self isMotorEnabled:1])[cmd appendString:[NSString stringWithFormat:@"F IA2M%d",(int)y*conversion.y]];
						if([cmd length]){
							[cmd appendString:@" R"];
							[cmdList addObject:cmd];
						}
                    }
                }
                else {
                    for(x=endx;x>=startx;x-=delta.x){
						NSMutableString* cmd = [NSMutableString string];
						if([self isMotorEnabled:0])[cmd appendString:[NSString stringWithFormat:@"F IA1M%d",(int)x*conversion.x]];
						if([self isMotorEnabled:1])[cmd appendString:[NSString stringWithFormat:@"F IA2M%d",(int)y*conversion.y]];
						if([cmd length]){
							[cmd appendString:@" R"];
							[cmdList addObject:cmd];
						}
                    }
                }
            }
        }
    }  
    
    if([cmdList count]){
        dwelling = NO;
        firstPosition = YES;
        [self performSelector:@selector(continuePattern) withObject:nil afterDelay:.1];
    }
    else {
        NSString* reason = [NSString stringWithFormat:@"VXM %d is synced to run but has no valid commands",[self  uniqueIdNumber]];
		
        [[NSNotificationCenter defaultCenter]
            postNotificationName:ORRequestRunHalt
                          object:self
                        userInfo:[NSDictionary dictionaryWithObjectsAndKeys:reason,@"Reason",nil]];
    }
}

- (void) stopPattern
{
    if([serialPort isOpen]){
        [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(continuePattern) object:nil];
        [self goHome];
    }
}


- (void) continuePattern
{
    [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(continuePattern) object:nil];
	
    if(![self moving]){
        if(!dwelling){
            dwelling = YES;
            waitingStartTime = [NSDate timeIntervalSinceReferenceDate];
        }
        else {
            if(firstPosition || [NSDate timeIntervalSinceReferenceDate] - waitingStartTime > dwellTime){
                firstPosition = NO;
                if([cmdList count]){
                    [self sendCmd:[cmdList objectAtIndex:0]];
                    [cmdList removeObjectAtIndex:0];    
                    dwelling = NO;
                }
                else {
                    if([self optionSet:kXYStopRunOption]){
						NSString* reason = [NSString stringWithFormat:@"VXM %d port finished pattern",[self  uniqueIdNumber]];
						
						[[NSNotificationCenter defaultCenter]
                                postNotificationName:ORRequestRunHalt
                                              object:self
                                            userInfo:[NSDictionary dictionaryWithObjectsAndKeys:reason,@"Reason",nil]];
                        
                    }
                    return;
                }
            }
        }
    }
    [self performSelector:@selector(continuePattern) withObject:nil afterDelay:.1];    
}

@end