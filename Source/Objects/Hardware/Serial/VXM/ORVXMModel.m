//--------------------------------------------------------
// ORVXMModel
// Created by Mark  A. Howe on Fri Jul 22 2005
// Code partially generated by the OrcaCodeWizard. Written by Mark A. Howe.
// Copyright (c) 2005 CENPA, University of Washington. All rights reserved.
//-----------------------------------------------------------
//This program was prepared for the Regents of the University of 
//Washington at the Center for Experimental Nuclear Physics and 
//Astrophysics (CENPA) sponsored in part by the United States 
//Department of Energy (DOE) under Grant #DE-FG02-97ER41020. 
//The University has certain rights in the program pursuant to 
//the contract and the program should not be copied or distributed 
//outside your organization.  The DOE and the University of 
//Washington reserve all rights in the program. Neither the authors,
//University of Washington, or U.S. Government make any warranty, 
//express or implied, or assume any liability or responsibility 
//for the use of this software.
//-------------------------------------------------------------

#pragma mark ***Imported Files

#import "ORVXMModel.h"
#import "ORVXMMotor.h"
#import "ORSerialPort.h"
#import "ORSerialPortList.h"
#import "ORSerialPort.h"
#import "ORSerialPortAdditions.h"
#import "ORDataTypeAssigner.h"
#import "ORDataPacket.h"

#pragma mark ***External Strings
NSString* ORVXMModelDisplayRawChanged		= @"ORVXMModelDisplayRawChanged";
NSString* ORVXMModelSerialPortChanged		= @"ORVXMModelSerialPortChanged";
NSString* ORVXMModelPortNameChanged			= @"ORVXMModelPortNameChanged";
NSString* ORVXMModelPortStateChanged		= @"ORVXMModelPortStateChanged";
NSString* ORVXMModelQueryInProgressChanged  = @"ORVXMModelQueryInProgressChanged";
NSString* ORVXMModelLastMotorQueryChanged   = @"ORVXMModelLastMotorQueryChanged";
NSString* ORVXMModelCmdQueueChanged			= @"ORVXMModelCmdQueueChanged";
NSString* ORVXMLock							= @"ORVXMLock";

@implementation ORVXMMotorCmd
@synthesize cmd, description,waitToSendNextCmd;
- (void) dealloc
{
	self.description = nil;
	self.cmd		 = nil;
	[super dealloc];
}
@end

@interface ORVXMModel (private)
- (void) runStarted:(NSNotification*)aNote;
- (void) runStopped:(NSNotification*)aNote;
- (void) timeout;
- (void) process_response:(NSString*)theResponse;
- (void) startTimeOut;
- (int)  getNextMotorToQuery;
- (void) makeMotors;
- (void) addCmdToQueue:(NSString*)aCmdString description:(NSString*)aDescription waitToSend:(BOOL)waitToSendNextCmd;
- (void) processNextCommand;
@end

@implementation ORVXMModel
- (id) init
{
	self = [super init];
    [self registerNotificationObservers];
	[[self undoManager] disableUndoRegistration];
    [self makeMotors];
    [[self undoManager] enableUndoRegistration];
	
	return self;
}

- (void) dealloc
{
	for(id aMotor in motors)[aMotor setDelegate:nil];
	[motors dealloc];
	[cmdQueue release];
	
    [[NSNotificationCenter defaultCenter] removeObserver:self];
    [NSObject cancelPreviousPerformRequestsWithTarget:self];
	[[NSNotificationCenter defaultCenter] removeObserver:self];
    [portName release];
    if([serialPort isOpen]){
        [serialPort close];
    }
    [serialPort release];
	[super dealloc];
}

- (void) setUpImage
{
	[self setImage:[NSImage imageNamed:@"VXM"]];
}

- (void) makeMainController
{
	[self linkToController:@"ORVXMController"];
}

- (void) registerNotificationObservers
{
	NSNotificationCenter* notifyCenter = [NSNotificationCenter defaultCenter];
	
    [notifyCenter addObserver : self
                     selector : @selector(dataReceived:)
                         name : ORSerialPortDataReceived
                       object : nil];
}

- (void) dataReceived:(NSNotification*)note
{
    if([[note userInfo] objectForKey:@"serialPort"] == serialPort){
        NSString* theString = [[[[NSString alloc] initWithData:[[note userInfo] objectForKey:@"data"] 
													  encoding:NSASCIIStringEncoding] autorelease] uppercaseString];        
        [self process_response:theString];
    }
}

- (void) shipMotorState:(BOOL)running
{
    if([[ORGlobal sharedGlobal] runInProgress]){
		//get the time(UT!)
		time_t	ut_time;
		time(&ut_time);
		
		int motorCount = [motors count];
		int numEntries = 3 + 2*motorCount;
		
		unsigned long* data = (unsigned long*)malloc(sizeof(long) * numEntries);
		data[0] = dataId | numEntries;
		data[1] = ut_time;
		data[2] = ((motorCount & 0x7) << 29) | (running?1:0)<<16 | ([self uniqueIdNumber]&0x0000fffff);
		int index = 3;
		for(id aMotor in motors){
			//encode the position 
			union {
				long asLong;
				float asFloat;
			}thePosition;
			
			thePosition.asFloat = [aMotor motorPosition]; //steps
			data[index++] = thePosition.asLong;
			
			thePosition.asFloat = [aMotor conversion]; //steps
			data[index++] = thePosition.asLong;
		}	
		[[NSNotificationCenter defaultCenter] postNotificationName:ORQueueRecordForShippingNotification 
															object:[NSData dataWithBytes:data length:sizeof(long)*numEntries]];
		free(data);
	}
}

#pragma mark ***Accessors
- (BOOL) displayRaw
{
    return displayRaw;
}

- (void) setDisplayRaw:(BOOL)aDisplayRaw
{
    [[[self undoManager] prepareWithInvocationTarget:self] setDisplayRaw:displayRaw];
    displayRaw = aDisplayRaw;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORVXMModelDisplayRawChanged object:self];
}

- (NSArray*) motors
{
	return motors;
}
- (ORVXMMotor*) motor:(int)aMotor
{
	if(aMotor>=0 && aMotor<[motors count]) return [motors objectAtIndex:aMotor];
	else return nil;
}

- (int) lastMotorQuery
{
    return lastMotorQuery;
}

- (void) setLastMotorQuery:(int)aMotor
{
    lastMotorQuery = aMotor;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORVXMModelLastMotorQueryChanged object:self];

}
- (BOOL) queryInProgress;
{
    return queryInProgress;
}

- (void) setQueryInProgress:(BOOL)state
{
    queryInProgress = state;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORVXMModelQueryInProgressChanged object:self];
}

- (BOOL) portWasOpen
{
    return portWasOpen;
}

- (void) setPortWasOpen:(BOOL)aPortWasOpen
{
    portWasOpen = aPortWasOpen;
}

- (NSString*) portName
{
    return portName;
}

- (unsigned) cmdQueueCount
{
	return [cmdQueue count];
}

- (NSString*) cmdQueueCommand:(int)index
{
	if(index < [cmdQueue count]){
		return [[cmdQueue objectAtIndex:index] cmd];
	}
	else return @"";
}

- (NSString*) cmdQueueDescription:(int)index
{
	if(index < [cmdQueue count]){
		return [[cmdQueue objectAtIndex:index] description];
	}
	else return @"";
}

- (void) setPortName:(NSString*)aPortName
{
    [[[self undoManager] prepareWithInvocationTarget:self] setPortName:portName];
    
    if(![aPortName isEqualToString:portName]){
        [portName autorelease];
        portName = [aPortName copy];    
		
        BOOL valid = NO;
        NSEnumerator *enumerator = [ORSerialPortList portEnumerator];
        ORSerialPort *aPort;
        while (aPort = [enumerator nextObject]) {
            if([portName isEqualToString:[aPort name]]){
                [self setSerialPort:aPort];
                if(portWasOpen){
                    [self openPort:YES];
                    if([serialPort isOpen]){
						[self performSelector:@selector(queryPosition) withObject:nil afterDelay:.3];
                    }
                }
                valid = YES;
                break;
            }
        } 
        if(!valid){
            [self setSerialPort:nil];
        }       
    }
	
    [[NSNotificationCenter defaultCenter] postNotificationName:ORVXMModelPortNameChanged object:self];
}

- (ORSerialPort*) serialPort
{
    return serialPort;
}

- (void) setSerialPort:(ORSerialPort*)aSerialPort
{
    [aSerialPort retain];
    [serialPort release];
    serialPort = aSerialPort;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:ORVXMModelSerialPortChanged object:self];
}

- (void) openPort:(BOOL)state
{
    if(state) {
        [serialPort open];
		[serialPort setSpeed:9600];
		[serialPort setParityNone];
		[serialPort setStopBits2:1];
		[serialPort setDataBits:8];
 		[serialPort commitChanges];
    }
    else      [serialPort close];
    portWasOpen = [serialPort isOpen];
    portWasOpen = [serialPort isOpen];
    [[NSNotificationCenter defaultCenter] postNotificationName:ORVXMModelPortStateChanged object:self];
    
}


#pragma mark ***Archival
- (id) initWithCoder:(NSCoder*)decoder
{
	self = [super initWithCoder:decoder];
	[[self undoManager] disableUndoRegistration];
	
	[self setDisplayRaw:	[decoder decodeBoolForKey:	@"displayRaw"]];
	[self setPortWasOpen:	[decoder decodeBoolForKey:	@"portWasOpen"]];
    [self setPortName:		[decoder decodeObjectForKey:@"portName"]];
	
	motors = [[decoder decodeObjectForKey:@"motors"] retain];
	if(!motors)[self makeMotors];
	int i = 0;
	for(id aMotor in motors){
		[aMotor setOwner:self];
		[aMotor setMotorId:i];
		i++;
	}
	[[self undoManager] enableUndoRegistration];
	
    [self registerNotificationObservers];
	
	return self;
}

- (void) encodeWithCoder:(NSCoder*)encoder
{
    [super encodeWithCoder:encoder];
    [encoder encodeBool:displayRaw  forKey: @"displayRaw"];
    [encoder encodeBool:portWasOpen forKey: @"portWasOpen"];
    [encoder encodeObject:portName	forKey: @"portName"];
    [encoder encodeObject:motors	forKey: @"motors"];
}

#pragma mark ***Motor Commands
- (void) queryPosition
{
	[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(queryPosition) object:nil];
    if([serialPort isOpen] && !queryInProgress){
        int motorToQuery = [self getNextMotorToQuery];
        NSString* cmd = nil;
        switch(motorToQuery){
            case 0: cmd = @"E,X"; break;
            case 1: cmd = @"E,Y"; break;
            case 2: cmd = @"E,Z"; break;
            case 3: cmd = @"E,T"; break;
        }
        if(cmd){
            [self setQueryInProgress:YES];
            [self setLastMotorQuery:motorToQuery];
			//NSLog(@"sending: %@   motor:%d\n",cmd,motorToQuery);
            [serialPort writeString:cmd];
            [self startTimeOut];
        }
        else {
            [self setQueryInProgress:NO];
        }
    }
}

- (void) addCmdFromTableFor:(int)aMotorIndex
{	
	if(aMotorIndex>=0 && aMotorIndex<[motors count]){	
		id aMotor = [motors objectAtIndex:aMotorIndex];
		if([aMotor absoluteMotion]){
			[self move:aMotorIndex to:(int)[aMotor targetPosition] speed:[aMotor motorSpeed]];
		}
		else {
			[self move:aMotorIndex dx:(int)[aMotor targetPosition] speed:[aMotor motorSpeed]];
		}
	}
}

- (void) stopAllMotion
{
    if([serialPort isOpen]){
		[cmdQueue removeAllObjects];
		[[NSNotificationCenter defaultCenter] postNotificationName:ORVXMModelCmdQueueChanged object:self];
        [serialPort writeString:@"F,K"];
		[self performSelector:@selector(queryPosition) withObject:nil afterDelay:.3];
    }
}

- (void) goToNexCommand
{
    if([serialPort isOpen]){
        [serialPort writeString:@"F,K"];
		[self performSelector:@selector(queryPosition) withObject:nil afterDelay:.3];		
	}
}

- (void) move:(int)motorIndex dx:(float)aPosition
{
	if(motorIndex>=0 && motorIndex<[motors count]){	
		NSString* aCmd = [NSString stringWithFormat:@"F,CI%dM%.0f,R\r",motorIndex+1,aPosition];
		float conversion = [[motors objectAtIndex:motorIndex] conversion];
		NSString* units = displayRaw?@"stps":@"mm";
		[self addCmdToQueue:aCmd 
				description:[NSString stringWithFormat:@"Move %d by %.2f%@",motorIndex,aPosition/conversion,units]
				 waitToSend:YES];
	}
}
- (void) move:(int)motorIndex dx:(float)aPosition speed:(int)aSpeed
{
	if(motorIndex>=0 && motorIndex<[motors count]){	
		NSString* aCmd = [NSString stringWithFormat:@"F,C,S%dM%d,I%dM%.0f,R\r",motorIndex+1,aSpeed,motorIndex+1,aPosition];
		float conversion = [[motors objectAtIndex:motorIndex] conversion];
		NSString* units = displayRaw?@"stps":@"mm";
		
		[self addCmdToQueue:aCmd 
				description:[NSString stringWithFormat:@"Move %d by %.2f%@ at %.2f%@/s",motorIndex,aPosition/conversion,units,aSpeed/conversion,units]
				 waitToSend:YES];
	}
}

- (void) move:(int)motorIndex to:(float)aPosition speed:(int)aSpeed
{
	if(motorIndex>=0 && motorIndex<[motors count]){	
		NSString* aCmd = [NSString stringWithFormat:@"F,C,S%dM%d,IA%dM%.0f,R\r",motorIndex+1,aSpeed,motorIndex+1,aPosition];
		float conversion = [[motors objectAtIndex:motorIndex] conversion];
		NSString* units = displayRaw?@"stps":@"mm";
		[self addCmdToQueue:aCmd 
				description:[NSString stringWithFormat:@"Move %d to %.2f%@ to %.2f%@/s",motorIndex,aPosition/conversion,units,aSpeed/conversion,units]
				 waitToSend:YES];
	}
}

- (void) move:(int)motorIndex to:(float)aPosition
{
	if(motorIndex>=0 && motorIndex<[motors count]){	
		NSString* aCmd = [NSString stringWithFormat:@"F,C,IA%dM%.0f,R\r",motorIndex+1,aPosition];
		float conversion = [[motors objectAtIndex:motorIndex] conversion];
		NSString* units = displayRaw?@"stps":@"mm";
		[self addCmdToQueue:aCmd 
				description:[NSString stringWithFormat:@"Move %d to %.2f%@",motorIndex,aPosition/conversion,units]
				 waitToSend:YES];
	}
}

- (void) goHome:(int)motorIndex speed:(int)aSpeed
{
	if([serialPort isOpen] && motorIndex>=0 && motorIndex<[motors count]){
		NSString* aCmd = [NSString stringWithFormat:@"F,C,S%dM%d,I%dM-0,R",motorIndex+1,aSpeed,motorIndex+1];
		[self addCmdToQueue:aCmd 
				description:[NSString stringWithFormat:@"Move %d home at %dmm/s",motorIndex,aSpeed]
				 waitToSend:YES];
		[self performSelector:@selector(queryPosition) 
				   withObject:nil 
				   afterDelay:.3];
    }
}

- (void) goHomeAll
{
    if([serialPort isOpen]){
		for(id aMotor in motors){
			if([aMotor motorEnabled]){
				int theMotorId = [aMotor motorId];
				float speed = [aMotor motorSpeed];
				[self goHome:theMotorId speed:speed];
			}
		}
    }
}

#pragma mark ***Data Records
- (unsigned long) dataId { return dataId; }
- (void) setDataId: (unsigned long) DataId
{
    dataId = DataId;
}
- (void) setDataIds:(id)assigner
{
    dataId       = [assigner assignDataIds:kLongForm];
}

- (void) syncDataIdsWith:(id)anotherVXM
{
    [self setDataId:[anotherVXM dataId]];
}

- (void) appendDataDescription:(ORDataPacket*)aDataPacket userInfo:(id)userInfo
{
    //----------------------------------------------------------------------------------------
    // first add our description to the data description
    [aDataPacket addDataDescriptionItem:[self dataRecordDescription] forKey:@"VXMModel"];
}

- (NSDictionary*) dataRecordDescription
{
    NSMutableDictionary* dataDictionary = [NSMutableDictionary dictionary];
    NSDictionary* aDictionary = [NSDictionary dictionaryWithObjectsAndKeys:
        @"ORVXMDecoderForPosition",   @"decoder",
        [NSNumber numberWithLong:dataId],   @"dataId",
        [NSNumber numberWithBool:NO],       @"variable",
        [NSNumber numberWithLong:5],        @"length",
        nil];
    [dataDictionary setObject:aDictionary forKey:@"Position"];
    
    return dataDictionary;
}

@end

@implementation ORVXMModel (private)

- (int) getNextMotorToQuery
{
    int nextMotor = lastMotorQuery;
	int count = [motors count];
	int i;
    for(i=0;i<kNumVXMMotors;i++){
        nextMotor = (nextMotor+1)%count;
		ORVXMMotor* aMotor = [self motor:nextMotor];
        if([aMotor motorEnabled]) return nextMotor;
    }
    return 0;
}

- (void) runStarted:(NSNotification*)aNote
{
	/*
    [[NSNotificationCenter defaultCenter]
        postNotificationName:ORVXMModelEndEditing
                      object:self];
	
    if([self optionSet:kXYSyncWithRunOption]){
        if([serialPort isOpen]){
            [self startPattern];
        }
        else {
            [self openPort:YES];
            if([serialPort isOpen]){
                [self startPattern];
            }
            else {
                //couldn't open port...stop the run.
                NSString* reason = [NSString stringWithFormat:@"VXM %d port could not be opened",[self  uniqueIdNumber]];
                
                [[NSNotificationCenter defaultCenter]
                    postNotificationName:ORRequestRunHalt
                                  object:self
                                userInfo:[NSDictionary dictionaryWithObjectsAndKeys:reason,@"Reason",nil]];
			}
        }
    }
	 */
}

- (void) runStopped:(NSNotification*)aNote
{/*
    if([self optionSet:kXYSyncWithRunOption]){
        [self stopPattern];
    }
  */
}

#pragma mark ***Command Handling
- (void) timeout
{
	NSLogError(@"Met237",@"command timeout",nil);
}

- (void) startTimeOut
{
	[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(timeout) object:nil];
	[self performSelector:@selector(timeout) withObject:nil afterDelay:3];
}

- (void) process_response:(NSString*)aCmd
{
    if([aCmd rangeOfString:@"^"].location != NSNotFound){
		//the '^' is send if a command is complete
		aCmd = [aCmd substringFromIndex:1]; //might be more on this response, strip off the '^'
		if([cmdQueue count]==0){
			[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(queryPosition) object:nil];
			[self setQueryInProgress:NO];
		}
		else {
			[cmdQueue removeObjectAtIndex:0];
			[self processNextCommand];
		}
	}
    if([aCmd length]>0) {
		if([aCmd hasPrefix:@"X"] || 
		   [aCmd hasPrefix:@"Y"] || 
		   [aCmd hasPrefix:@"Z"] || 
		   [aCmd hasPrefix:@"T"] ){
				aCmd = [aCmd substringFromIndex:1];
		}
		
		ORVXMMotor* aMotor = [motors objectAtIndex:lastMotorQuery];
		if(queryInProgress){
			float aValue = [aCmd floatValue];
			[aMotor setMotorPosition:aValue];
			[self setQueryInProgress:NO];
		}
		[self performSelector:@selector(queryPosition) withObject:nil afterDelay:.3];
    }
    [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(timeout) object:nil];
}

- (void) makeMotors
{
    if(!motors){
		motors = [[NSMutableArray arrayWithCapacity:kNumVXMMotors] retain];
		int i;
		for(i=0;i<kNumVXMMotors;i++){
			ORVXMMotor* aMotor = [[ORVXMMotor alloc] initWithOwner:self motorNumber:i];
			[motors addObject:aMotor];
			[aMotor release];
		}
	}
}

- (void) addCmdToQueue:(NSString*)aCmdString description:(NSString*)aDescription waitToSend:(BOOL)waitToSendNextCmd
{
	if([serialPort isOpen]){ 
		if(!cmdQueue)cmdQueue	= [[NSMutableArray array] retain];
		ORVXMMotorCmd* aCmd		= [[ORVXMMotorCmd alloc] init];
		aCmd.cmd				= aCmdString;
		aCmd.description		= aDescription;
		aCmd.waitToSendNextCmd	= waitToSendNextCmd;
		[cmdQueue addObject:aCmd];
		[aCmd release];
		if([cmdQueue count]==1)[self processNextCommand];
	}
	[[NSNotificationCenter defaultCenter] postNotificationName:ORVXMModelCmdQueueChanged object:self];
}

- (void) processNextCommand
{
	if([serialPort isOpen]){ 
		if([cmdQueue count]!=0){
			ORVXMMotorCmd* aCmd = [cmdQueue objectAtIndex:0];
			[serialPort writeString:aCmd.cmd];
			if(!aCmd.waitToSendNextCmd){
				[cmdQueue removeObjectAtIndex:0];
				[self processNextCommand];
			}
		}
	}
	[[NSNotificationCenter defaultCenter] postNotificationName:ORVXMModelCmdQueueChanged object:self];
}

@end