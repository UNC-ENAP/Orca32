//
//  FilterScript.hym
//  Orca
//
//  Created by Mark Howe on Fri Jan 25 2008.
//  Copyright (c) 2002 CENPA, University of Washington. All rights reserved.
//-----------------------------------------------------------
//This program was prepared for the Regents of the University of 
//Washington at the Center for Experimental Nuclear Physics and 
//Astrophysics (CENPA) sponsored in part by the United States 
//Department of Energy (DOE) under Grant #DE-FG02-97ER41020. 
//The University has certain rights in the program pursuant to 
//the contract and the program should not be copied or distributed 
//outside your organization.  The DOE and the University of 
//Washington reserve all rights in the program. Neither the authors,
//University of Washington, or U.S. Government make any warranty, 
//express or implied, or assume any liability or responsibility 
//for the use of this software.
//-------------------------------------------------------------
%{
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include "FilterScript.h"
#import "ORHashTable.h"

/* prototypes */
nodeType* opr(int oper, int nops, ...);
nodeType* ident(char*);
nodeType* con(int value);

void freeNode(nodeType *p);
void addFilterNode(nodeType* node);

nodeType** allFilterNodes = 0;
long filterNodeCount = 0;
long maxFilterNodeCount = 0;

int ex(nodeType *p);
int yylex(void);
BOOL parsedSuccessfully;
void yyerror(char *s);
ORHashTable* symbolTable;
%}

%union {
    int iValue;                 /* integer value */
    char sIndex[64];            /* symbol table key */
    nodeType *nPtr;             /* node pointer */
};

%token <iValue> INTEGER
%token <sIndex> VARIABLE
%token FUNCTION WHILE DO FOR IF PRINT BREAK EXIT CONTINUE SLEEP RETURN WAITUNTIL HEX
%token INC_OP DEC_OP ADD_ASSIGN SUB_ASSIGN MUL_ASSIGN DIV_ASSIGN ORQUALS LEFT_ASSIGN RIGHT_ASSIGN
%token AND_ASSIGN XOR_ASSIGN MOD_ASSIGN OR_ASSIGN MAKESTRING SWITCH CASE DEFAULT 
%token LEFT_OP RIGHT_OP  EQ_OP NE_OP GE_OP LE_OP AND_OP OR_OP ALARM CLEAR HELLO
%nonassoc IFX
%nonassoc ELSE

%left GE LE EQ NE '>' '<'
%left '+' '-'
%left  '%' '*' '/' ','
%nonassoc NOT UMINUS INVERT

%type <nPtr>  function statement expr statement_list compound_statement expression_statement
%type <nPtr>  selection_statement iteration_statement primary_expr postfix_expr unary_expr multiplicative_expr
%type <nPtr>  additive_expr shift_expr relational_expr equality_expr and_expr exclusive_or_expr inclusive_or_expr
%type <nPtr>  logical_and_expr logical_or_expr conditional_expr assignment_expr jump_statement case_statement
%type <nPtr>  case_list break_statement constant_expr print_statement print_list special_statement
%%

program:
        funclist                { return 1; }
        ;


funclist:
		  funcdef
		| funclist funcdef
		;

funcdef:
          FUNCTION VARIABLE '(' ')' '{' function '}' {parsedSuccessfully = YES; nodeType* a = ident($2); printf("got %s\n",a->ident.key);	}			
        ;


function:
          function statement         {addFilterNode($2);}
		  | /*NULL*/
        ;

statement:
		compound_statement				{ $$ = $1;}
		| expression_statement			{ $$ = $1;}
 		| selection_statement			{ $$ = $1;}
		| iteration_statement			{ $$ = $1;}
		| jump_statement				{ $$ = $1;}
		| special_statement				{ $$ = $1;}
		| VARIABLE ';'					{ FilterScripterror ("unrecognized keyword"); return 1;}
		;
		
special_statement 
		: print_statement				{ $$ = $1; }
		;

statement_list:
          statement                  { $$ = $1; }
        | statement_list statement   { $$ = opr(';', 2, $1, $2); }
        ;

compound_statement: 
		  '{' '}'						{ $$ = opr(';', 0); }
		| '{' statement_list '}'		{ $$ = $2;}
		;							

expression_statement
		: ';'							{ $$ = opr(';', 0); }
		| expr ';'						{ $$ = $1;}
		;		

selection_statement
		: IF '(' expr ')' statement					{ $$ = opr(IF,2, $3, $5); }
		| IF '(' expr ')' statement ELSE statement	{ $$ = opr(IF,3, $3, $5, $7); }
		;

iteration_statement
		: WHILE '(' expr ')' statement					{ $$ = opr(WHILE, 2, $3, $5); }
		| FOR '(' expr ';' expr ';' expr ')' statement	{ $$ = opr(FOR,4, $3,$5,$7,$9); }
		| DO statement WHILE '(' expr ')'				{ $$ = opr(DO,2, $2,$5); }
		;

jump_statement 
		: CONTINUE ';'		{ $$ = opr(CONTINUE,0);}
		| BREAK ';'			{ $$ = opr(BREAK,0); }
		| RETURN ';'		{ $$ = opr(RETURN,0);}
		| EXIT ';'			{ $$ = opr(EXIT,0);}
		| RETURN expr ';'	{ $$ = opr(RETURN,1,$2);}
		;

case_list
	: case_statement							{ $$ = $1;}
	| case_list case_statement					{ $$ = executionNode(';', $1, $2,nil); }
	;
	
case_statement
	: CASE constant_expr ':' statement_list	break_statement		{ $$ = executionNode(CASE, $2, $4, $5,nil); }
	| DEFAULT ':' statement_list	break_statement				{ $$ = executionNode(DEFAULT, $3, $4, nil); }
	;

break_statement
	: BREAK	';'							{ $$ = executionNode(BREAK,nil); }

constant_expr
	: conditional_expr				{ $$ = $1; }
	;

expr
		: assignment_expr			{ $$ = $1; }
        ;

primary_expr
		: VARIABLE					{ $$ = ident($1); }
		| INTEGER					{ $$ = con($1); }
		| '(' expr ')'				{ $$ = $2; }
		| HELLO '(' expr ')'		{ $$ = opr(HELLO,1,$3);}
		;
	
postfix_expr
		: primary_expr				{ $$ = $1;}
		| postfix_expr INC_OP		{ $$ = opr(kPostInc,1,$1);}
		| postfix_expr DEC_OP		{ $$ = opr(kPostDec,1,$1);}
		;

unary_expr
		: postfix_expr					{ $$ = $1;}
		| INC_OP unary_expr				{ $$ = opr(kPreInc,1,$2);}
		| DEC_OP unary_expr				{ $$ = opr(kPreDec,1,$2);}
		| '-' primary_expr %prec UMINUS	{ $$ = opr(UMINUS,1, $2); }
        | '!' primary_expr %prec NOT	{ $$ = opr('!',1, $2); }
        | '~' primary_expr %prec INVERT	{ $$ = opr('~',1, $2); }
		;

multiplicative_expr
		: unary_expr								{$$ = $1;}
		| multiplicative_expr '*' unary_expr		{ $$ = opr('*', 2, $1, $3); }
		| multiplicative_expr '/' unary_expr		{ $$ = opr('/', 2, $1, $3); }
		| multiplicative_expr '%' unary_expr		{ $$ = opr('%', 2, $1, $3); }
		;

additive_expr
		: multiplicative_expr						{ $$ = $1;}
		| additive_expr '+' multiplicative_expr		{ $$ = opr('+', 2, $1, $3); }
		| additive_expr '-' multiplicative_expr		{ $$ = opr('-', 2, $1, $3); }
		;

shift_expr
		: additive_expr								{ $$ = $1;}
		| shift_expr LEFT_OP additive_expr			{ $$ = opr(LEFT_OP, 2,  $1, $3); }
		| shift_expr RIGHT_OP additive_expr			{ $$ = opr(RIGHT_OP, 2,  $1, $3); }
		;

relational_expr
		: shift_expr								{ $$ = $1;}
		| relational_expr '<' shift_expr			{ $$ = opr('<',   2,  $1, $3); }
		| relational_expr '>' shift_expr			{ $$ = opr('>',   2,  $1, $3); }
		| relational_expr LE_OP shift_expr			{ $$ = opr(LE_OP, 2,  $1, $3); }
		| relational_expr GE_OP shift_expr			{ $$ = opr(GE_OP, 2,  $1, $3); }
		;

equality_expr
		: relational_expr								{ $$ = $1;}
		| equality_expr EQ_OP relational_expr			{ $$ = opr(EQ_OP, 2,  $1, $3); }
		| equality_expr NE_OP relational_expr			{ $$ = opr(NE_OP, 2,  $1, $3); }
		;
		
and_expr
		: equality_expr									{ $$ = $1;}
		| and_expr '&' equality_expr					{ $$ = opr('&', 2,  $1, $3); }
		;

exclusive_or_expr
		: and_expr										{ $$ = $1;}
		| exclusive_or_expr '^' and_expr				{ $$ = opr('^', 2,  $1, $3); }
		;

inclusive_or_expr
		: exclusive_or_expr								{ $$ = $1;}
		| inclusive_or_expr '|' exclusive_or_expr		{ $$ = opr('|', 2,  $1, $3); }
		;

logical_and_expr
		: inclusive_or_expr								{ $$ = $1;}
		| logical_and_expr AND_OP inclusive_or_expr		{ $$ = opr(AND_OP, 2,  $1, $3); }
		;

logical_or_expr
		: logical_and_expr								{ $$ = $1;}
		| logical_or_expr OR_OP logical_and_expr		{ $$ = opr(OR_OP, 2,  $1, $3); }
		;

conditional_expr
		: logical_or_expr											{ $$ = $1;}
		| logical_or_expr '?' logical_or_expr ':' conditional_expr	{ $$ = opr(kConditional, 3,$1,$3,$5);}
		;

assignment_expr
		: conditional_expr									{ $$ = $1;}
		| VARIABLE '=' assignment_expr						{ $$ = opr('=',2,ident($1),$3);}
		| unary_expr MUL_ASSIGN assignment_expr				{ $$ = opr(MUL_ASSIGN,2,$1,$3);}
		| unary_expr DIV_ASSIGN assignment_expr				{ $$ = opr(DIV_ASSIGN,2,$1,$3);}
		| unary_expr MOD_ASSIGN assignment_expr				{ $$ = opr(MOD_ASSIGN,2,$1,$3);}
		| unary_expr ADD_ASSIGN assignment_expr				{ $$ = opr(ADD_ASSIGN,2,$1,$3);}
		| unary_expr SUB_ASSIGN assignment_expr				{ $$ = opr(SUB_ASSIGN,2,$1,$3);}
		| unary_expr LEFT_ASSIGN assignment_expr			{ $$ = opr(LEFT_ASSIGN,2,$1,$3);}
		| unary_expr RIGHT_ASSIGN assignment_expr			{ $$ = opr(RIGHT_ASSIGN,2,$1,$3);}
		| unary_expr AND_ASSIGN assignment_expr				{ $$ = opr(AND_ASSIGN,2,$1,$3);}
		| unary_expr XOR_ASSIGN assignment_expr				{ $$ = opr(XOR_ASSIGN,2,$1,$3);}
		| unary_expr OR_ASSIGN assignment_expr				{ $$ = opr(OR_ASSIGN,2,$1,$3);}
		;

//---print stuff-----------------------------------------------------------
//ex: print "test:",i;
//ex: print ("test:",i);
print_statement
		: PRINT '(' print_list ')' ';'	{ $$ = opr(PRINT,1, $3); }
		| PRINT  print_list  ';'		{ $$ = opr(PRINT,1, $2); }
		;
//the arguments for the print or string functions
print_list
		: assignment_expr					{ $$ = $1; }
		;


%%

#define SIZEOF_NODETYPE ((char *)&p->con - (char *)p)

void addFilterNode(nodeType* aNode)
{
	if(!allFilterNodes){
		filterNodeCount = 0;
		maxFilterNodeCount = 1000;
		allFilterNodes = (nodeType**)malloc(maxFilterNodeCount*sizeof(nodeType));
		symbolTable = [[ORHashTable alloc] init];
	}
	allFilterNodes[filterNodeCount++] = aNode;
	if(filterNodeCount>maxFilterNodeCount){
		maxFilterNodeCount += 1000;
		allFilterNodes = (nodeType**)realloc(allFilterNodes, maxFilterNodeCount*sizeof(nodeType));
	}
}

nodeType *con(int value) {
    nodeType *p;
    size_t nodeSize;

    /* allocate node */
    nodeSize = SIZEOF_NODETYPE + sizeof(conNodeType);
    if ((p = malloc(nodeSize)) == NULL) yyerror("out of memory");

    /* copy information */
    p->type = typeCon;
    p->con.value = value;

    return p;
}

nodeType *ident(char* key) {
    nodeType *p;
    size_t nodeSize;

    /* allocate node */
    nodeSize = SIZEOF_NODETYPE + sizeof(idNodeType);
    if ((p = malloc(nodeSize)) == NULL) yyerror("out of memory");

    /* copy information */
    p->type = typeId;
    strcpy(p->ident.key,key);

    return p;
}

nodeType *opr(int oper, int nops, ...) {
    va_list ap;
    nodeType *p;
    size_t nodeSize;
    int i;

    /* allocate node */
    nodeSize = SIZEOF_NODETYPE + sizeof(oprNodeType) + (nops - 1) * sizeof(nodeType*);
    if ((p = malloc(nodeSize)) == NULL) yyerror("out of memory");

    /* copy information */
    p->type = typeOpr;
    p->opr.oper = oper;
    p->opr.nops = nops;
    va_start(ap, nops);
    for (i = 0; i < nops; i++) p->opr.op[i] = va_arg(ap, nodeType*);
    va_end(ap);
    return p;
}

void freeNode(nodeType *p) {
    int i;

    if (!p) return;
    if (p->type == typeOpr) {
        for (i = 0; i < p->opr.nops; i++) freeNode(p->opr.op[i]);
    }
    free (p);
}

void yyerror(char *s) {
    fprintf(stdout, "%s\n", s);
}

