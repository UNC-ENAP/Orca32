//--------------------------------------------------------
// ORListenerModel
// Created by Mark  A. Howe on Mon Apr 11 2005
// Code partially generated by the OrcaCodeWizard. Written by Mark A. Howe.
// Copyright (c) 2005 CENPA, University of Washington. All rights reserved.
//-----------------------------------------------------------
//This program was prepared for the Regents of the University of 
//Washington at the Center for Experimental Nuclear Physics and 
//Astrophysics (CENPA) sponsored in part by the United States 
//Department of Energy (DOE) under Grant #DE-FG02-97ER41020. 
//The University has certain rights in the program pursuant to 
//the contract and the program should not be copied or distributed 
//outside your organization.  The DOE and the University of 
//Washington reserve all rights in the program. Neither the authors,
//University of Washington, or U.S. Government make any warranty, 
//express or implied, or assume any liability or responsibility 
//for the use of this software.
//-------------------------------------------------------------

#pragma mark ***Imported Files

#import "ORListenerModel.h"
#import "NetSocket.h"
#import "ORDataTaker.h"
#import "ORDecoder.h"
#import "ORSafeQueue.h"
#import "ORDataTaker.h"
#import "ORDataTypeAssigner.h"
#import "ORDataProcessing.h"

#pragma mark ***External Strings
NSString* ORListenerConnectAtStartChanged	= @"ORListenerConnectAtStartChanged";
NSString* ORListenerAutoReconnectChanged	= @"ORListenerAutoReconnectChanged";
NSString* ORListenerQueueCountChanged		= @"ORListenerQueueCountChanged";
NSString* ORListenerRemotePortChanged		= @"ORListenerRemotePortChanged";
NSString* ORListenerRemoteHostChanged		= @"ORListenerRemoteHostChanged";
NSString* ORListenerIsConnectedChanged		= @"ORListenerIsConnectedChanged";
NSString* ORListenerByteCountChanged		= @"ORListenerByteCountChanged";
NSString* ORListenerLock                    = @"ORListenerLock";

static NSString* ORListenerConnector = @"ORListenerConnector";

#define kProcessingBusy 1
#define kProcessingDone 0
#define kMaxQueueSize   10*1024

@interface ORListenerModel (processThread)
- (void) processDataFromQueue;
- (void) process:(NSMutableData*)dataChunk;
- (void) startProcessing;
- (void) stopProcessing;
- (void) reConnect;
@end

@interface ORListenerModel (private)
- (void) setCurrentDecoder:(ORDecoder*)aDecoder;
- (void) loadRunInfoFromRunRecord:(unsigned long*)p;
- (void) loadRunInfoFromHeader;
- (void) processRunRecord:(unsigned long*)p;
- (void) sendDataArray:(NSArray*)dataArray decoder:(ORDecoder*)aDecoder;
- (void) sendByteUpdateDelayed;
- (void) sendByteUpdate;

@end

@implementation ORListenerModel
- (id) init
{
	self = [super init];
    readingLock = [[NSLock alloc] init];
	return self;
}

- (void) dealloc
{
    [[NSNotificationCenter defaultCenter] removeObserver:self];
	[NSObject cancelPreviousPerformRequestsWithTarget:self];
	[timeToStopProcessThread release];
    [readingLock release];
	[remoteHost release];
	[socket release];
	[transferQueue release];
	[dataArray release];
	[currentDecoder release];
	[dataToProcess release];
	[runInfo release];
	[super dealloc];
}

- (void) setUpImage
{
	[self setImage:[NSImage imageNamed:@"Listener"]];
}

- (void) makeMainController
{
	[self linkToController:@"ORListenerController"];
}

- (NSString*) helpURL
{
	return @"Data_Chain/Listener.html";
}

- (void) makeConnectors
{
    ORConnector* aConnector = [[ORConnector alloc] initAt:NSMakePoint([self frame].size.width-kConnectorSize,[self frame].size.height/2 - kConnectorSize/2) withGuardian:self withObjectLink:self];
    [[self connectors] setObject:aConnector forKey:ORListenerConnector];
	[aConnector setIoType:kOutputConnector];
    [aConnector release];
    
}

#pragma mark ¥¥¥Notifications
- (void) registerNotificationObservers
{
    NSNotificationCenter* notifyCenter = [NSNotificationCenter defaultCenter];
    
    [notifyCenter addObserver : self
                     selector : @selector(connectionChanged:)
                         name : ORConnectionChanged
                       object : nil];
    
    [notifyCenter addObserver : self
                     selector : @selector(documentLoaded:)
                         name : ORDocumentLoadedNotification
                       object : nil];
    
    
}

- (void) documentLoaded:(NSNotification*)aNotification
{
    if([self objectConnectedTo:ORListenerConnector] && connectAtStart){
        docLoaded = YES;
        [self connectSocket:YES];
    }
}

- (void) connectionChanged:(NSNotification*)aNotification
{
    if([aNotification object] == self){
        if([self objectConnectedTo:ORListenerConnector]){
            if(docLoaded){
                [self connectSocket:YES];
            }
        }
        else {
            [self connectSocket:NO];
        }
    }
}

#pragma mark ***Accessors

- (BOOL) connectAtStart
{
	return connectAtStart;
}

- (void) setConnectAtStart:(BOOL)aConnectAtStart
{
	[[[self undoManager] prepareWithInvocationTarget:self] setConnectAtStart:connectAtStart];
    
	connectAtStart = aConnectAtStart;
    
	[[NSNotificationCenter defaultCenter]
	 postNotificationName:ORListenerConnectAtStartChanged
	 object:self];
}
- (BOOL) autoReconnect
{
	return autoReconnect;
}
- (void) setAutoReconnect:(BOOL)aAutoReconnect
{
	[[[self undoManager] prepareWithInvocationTarget:self] setAutoReconnect:autoReconnect];
    
	autoReconnect = aAutoReconnect;
    
	[[NSNotificationCenter defaultCenter]
	 postNotificationName:ORListenerAutoReconnectChanged
	 object:self];
}

- (ORSafeQueue*) transferQueue
{
	return transferQueue;
}

- (void) setTransferQueue:(ORSafeQueue*)aTransferQueue
{
	[aTransferQueue retain];
	[transferQueue release];
	transferQueue = aTransferQueue;
}

- (unsigned long) queueCount
{
	return queueCount;
}
- (void) setQueueCount:(unsigned long)aQueueCount
{
	queueCount = aQueueCount;
    
	[[NSNotificationCenter defaultCenter]
	 postNotificationName:ORListenerQueueCountChanged
	 object:self];
}

- (NetSocket*) socket
{
	return socket;
}
- (void) setSocket:(NetSocket*)aSocket
{
	[aSocket retain];
	[socket release];
	socket = aSocket;
    [socket setDelegate:self];
}

- (unsigned short) remotePort
{
	return remotePort;
}
- (void) setRemotePort:(unsigned short)aNewRemotePort
{
	[[[self undoManager] prepareWithInvocationTarget:self] setRemotePort:remotePort];
    
	remotePort = aNewRemotePort;
    
	[[NSNotificationCenter defaultCenter] 
	 postNotificationName:ORListenerRemotePortChanged 
	 object: self];
}

- (NSString*) remoteHost
{
	return remoteHost;
}
- (void) setRemoteHost:(NSString*)aNewRemoteHost
{
    if(!aNewRemoteHost)aNewRemoteHost = @"";
    
    NSString* thisHostAdress    = [[NSHost currentHost] address];
    NSString* remoteHostAddress = [[NSHost hostWithName:aNewRemoteHost] address];
    
    if([thisHostAdress isEqualToString:remoteHostAddress]){
        aNewRemoteHost = @"";   
        NSLog(@"Sorry, you can not connect a Listener to the local host.\n"); 
        NSLog(@"The remote host must be a different computer.\n"); 
    }
    
	[[[self undoManager] prepareWithInvocationTarget:self] setRemoteHost:remoteHost];
    
	[remoteHost autorelease];
	remoteHost = [aNewRemoteHost copy];
    
	[[NSNotificationCenter defaultCenter] 
	 postNotificationName:ORListenerRemoteHostChanged 
	 object: self ];
}

- (BOOL) isConnected
{
	return isConnected;
}
- (void) setIsConnected:(BOOL)aNewIsConnected
{
	isConnected = aNewIsConnected;
    
	[[NSNotificationCenter defaultCenter] 
	 postNotificationName:ORListenerIsConnectedChanged 
	 object: self ];
}

- (unsigned long) byteCount
{
	return byteCount;
}
- (void) setByteCount:(unsigned long)aNewByteCount
{
	byteCount = aNewByteCount;
	if(!scheduledForUpdate){
		byteCount = 0;
		[self performSelectorOnMainThread:@selector(sendByteUpdateDelayed) withObject:nil waitUntilDone:NO];
		scheduledForUpdate = YES;
	}
}

- (void) clearByteCount
{
    [self setByteCount:0];
}

- (void) incByteCount:(unsigned long)anAmount
{
    unsigned long newAmount = byteCount + anAmount;
	[self setByteCount:newAmount];
}

- (void) connectSocket:(BOOL)state
{
    if(state){
		[dataArray release];
		dataArray = [[NSMutableArray arrayWithCapacity:1024*1024] retain];
		firstTime = YES;
        [self setSocket:[NetSocket netsocketConnectedToHost:remoteHost port:remotePort]];
		[self setCurrentDecoder:[[[ORDecoder alloc] init] autorelease]];
    }
    else {
        [socket close];
        [self stopProcessing];
        [self setIsConnected:[socket isConnected]];
    }
}

#pragma mark ***Delegate Methods
- (void) netsocketConnected:(NetSocket*)inNetSocket
{
    if(inNetSocket == socket){
        [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(reConnect) object:nil];
        [self startProcessing];
        [self setIsConnected:[socket isConnected]];
        [self setIsConnected:YES];
    }
}

- (void) netsocketDisconnected:(NetSocket*)inNetSocket
{
    if(inNetSocket == socket){
        [self stopProcessing];
        [self setIsConnected:[socket isConnected]];
        if(autoReconnect)[self performSelector:@selector(reConnect) withObject:nil afterDelay:10];
        [self setIsConnected:NO];
    }
}

- (void) netsocket:(NetSocket*)inNetSocket dataAvailable:(unsigned)inAmount
{
    if(inNetSocket == socket){
        id theData = [socket readData];
        if(theData){
            [transferQueue enqueue:theData];
            [self incByteCount:inAmount];
        }
    }
}

#pragma mark ***Archival

- (id) initWithCoder:(NSCoder*)decoder
{
	self = [super initWithCoder:decoder];
	[[self undoManager] disableUndoRegistration];
    
	[self setRemoteHost:[decoder decodeObjectForKey:@"ORListenerRemoteHost"]];
    [self setConnectAtStart:[decoder decodeBoolForKey:@"ConnectAtStart"]];
    [self setAutoReconnect:[decoder decodeBoolForKey:@"AutoReconnect"]];
	[self setRemotePort:[decoder decodeIntForKey:@"ORListenerRemotePort"]];
    
	[[self undoManager] enableUndoRegistration];
    
    if(remotePort==0)remotePort = 44666;
	[self registerNotificationObservers];
    readingLock = [[NSLock alloc] init];
    
	return self;
}
- (void) encodeWithCoder:(NSCoder*)encoder
{
    [super encodeWithCoder:encoder];
	[encoder encodeObject:remoteHost forKey:@"ORListenerRemoteHost"];
    [encoder encodeBool:connectAtStart forKey:@"ConnectAtStart"];
    [encoder encodeBool:autoReconnect forKey:@"AutoReconnect"];
	[encoder encodeInt:remotePort forKey:@"ORListenerRemotePort"];
}

- (NSMutableDictionary*) addParametersToDictionary:(NSMutableDictionary*)dictionary
{
	NSMutableDictionary* objDictionary = [NSMutableDictionary dictionary];
    if(remoteHost)[objDictionary setObject:remoteHost forKey:@"RemoteHost"];
    [objDictionary setObject:[NSNumber numberWithInt:connectAtStart] forKey:@"ConnectAtStart"];
    [objDictionary setObject:[NSNumber numberWithInt:autoReconnect] forKey:@"AutoReconnect"];
    [objDictionary setObject:[NSNumber numberWithInt:remotePort] forKey:@"RemotePort"];
    [dictionary setObject:objDictionary forKey:@"Listener"];
    
    return objDictionary;
}


@end

@implementation ORListenerModel (processThread)
//-----------------------------------------------------------
//processDataFromQueue runs out of the processing thread
//-----------------------------------------------------------
- (void) processDataFromQueue
{
    
    if(![socket isConnected])return;
	
	BOOL flushMessagePrintedOnce = NO;
    BOOL timeToQuit              = NO;
    threadRunning                = YES;
    do {
        NSAutoreleasePool *pool = [[NSAutoreleasePool allocWithZone:nil] init];
        queueCount = [transferQueue count];
        if(queueCount){
			[dataToProcess appendData:[transferQueue dequeue]];
            [self process:dataToProcess];
        }
        if([timeToStopProcessThread condition]){
            queueCount = [transferQueue count];
            if(!flushMessagePrintedOnce){
                if(queueCount){
                    NSLog(@"flushing %d block%@ from listening queue\n",queueCount,(queueCount>1)?@"s ":@" ");
                }
                flushMessagePrintedOnce = YES;						
            }
            if(queueCount == 0){
                timeToQuit = YES;
            }
        }
        [pool release];
    } while(!timeToQuit);
    
    threadRunning = NO;
}

- (void) process:(NSMutableData*)dataChunk
{
	unsigned long* p			= (unsigned long*)[dataToProcess bytes];
	unsigned long* endPtr		= p + [dataToProcess length]/sizeof(long);
	unsigned long bytesProcessed	= 0;
	while(p<endPtr){
		unsigned long firstWord		= *p;
		//the first time is a special case. We have to have a header as the first record or we can not continue
		if(firstTime){
			runEnded = NO;
			if([dataChunk length]>sizeof(long)){
				if([currentDecoder legalData:dataChunk]){
					if(needToSwap)firstWord		= CFSwapInt32(*p);
					unsigned long recordLength	= ExtractLength(firstWord);
					if(p+recordLength <= endPtr){
						//OK we have enough to load the header and make a decoder
						[currentDecoder loadHeader:p];
						needToSwap = [currentDecoder needToSwap];
						[self loadRunInfoFromHeader];
						id nextObject = [self objectConnectedTo:ORListenerConnector];
						[nextObject runTaskStarted:runInfo];
						firstTime = NO;
					}
				}
				else {
					break;
				}
			}
		}
		else {
			if(needToSwap)firstWord		= CFSwapInt32(*p);
			unsigned long dataId		= ExtractDataId(firstWord);
			unsigned long recordLength	= ExtractLength(firstWord);
			
			if(p+recordLength <= endPtr){
				if(needToSwap){
					[currentDecoder byteSwapData:p forKey:[NSNumber numberWithLong:dataId]];
				}
				if(dataId == 0x0){
					[currentDecoder loadHeader:p];
					needToSwap = [currentDecoder needToSwap];
					runDataID = [[currentDecoder headerObject:@"dataDescription",@"ORRunModel",@"Run",@"dataId",nil] longValue];
				}
				else if(dataId == runDataID){
					[self processRunRecord:p];
				}
				
				[dataArray addObject:[NSData dataWithBytes:p length:recordLength*sizeof(long)]];
				
				p += recordLength;
				bytesProcessed += recordLength*sizeof(long);
				
				if(runEnded){
					if([dataArray count]){
						[self sendDataArray:dataArray decoder:currentDecoder];
						[dataArray removeAllObjects];
					}
					id nextObject = [self objectConnectedTo:ORListenerConnector];
					[nextObject closeOutRun:runInfo];
					[self setByteCount:0];
					break;
				}
				if(p>=endPtr)break;
			}
			else break;
		}

	}
	[dataToProcess replaceBytesInRange:NSMakeRange( 0, bytesProcessed ) withBytes:NULL length:0];	

	if([dataArray count]){
		[self sendDataArray:dataArray decoder:currentDecoder];
		[dataArray removeAllObjects];
	}
	
}

- (void) startProcessing
{
    if(!threadRunning && [socket isConnected]){
        [self setByteCount:0];
        if(!transferQueue){
            [self setTransferQueue:[[[ORSafeQueue alloc] init] autorelease]];
        }
        dataToProcess = [[NSMutableData alloc] init];
        //set up the process thread control lock
        if( timeToStopProcessThread ) [ timeToStopProcessThread release ];
        timeToStopProcessThread  = [[ NSConditionLock alloc ] initWithCondition: NO ];
        [NSThread detachNewThreadSelector:@selector(processDataFromQueue) toTarget:self withObject:nil];
    }        
}

- (void) stopProcessing
{
    if(threadRunning){
        [timeToStopProcessThread unlockWithCondition: YES];
        
        //....wait for processing to finish.....
        //wait for the processing thread to exit.
        BOOL timeout = NO;
        NSTimeInterval t0 = [NSDate timeIntervalSinceReferenceDate];
        while(threadRunning){
            [NSThread sleepUntilDate:[[NSDate date] addTimeInterval:.01]];
            if([NSDate timeIntervalSinceReferenceDate]-t0 > 10){
                timeout = YES;
                threadRunning = NO;
                break;
            }
        }
	}
	[dataToProcess release];
	dataToProcess = nil;
	[self setByteCount:0];
	[socket readData];
}

- (void) reConnect
{
    [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(reConnect) object:nil];
    [self connectSocket:YES];
}

@end

@implementation ORListenerModel (private)

- (void) sendByteUpdateDelayed
{
	[self performSelector:@selector(sendByteUpdate) withObject:nil afterDelay:1.0];
}

- (void) sendByteUpdate
{
	[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(sendByteUpdate) object:nil];
	[[NSNotificationCenter defaultCenter] postNotificationName:ORListenerByteCountChanged object: self ];
	scheduledForUpdate = NO;
}
- (void) setCurrentDecoder:(ORDecoder*)aDecoder
{
	[aDecoder retain];
	[currentDecoder release];
	currentDecoder = aDecoder;
}

- (void) loadRunInfoFromRunRecord:(unsigned long*)p
{
	//pack up some info about the run.
	[runInfo release];
	runInfo = [[NSMutableDictionary dictionaryWithObjectsAndKeys:
				[currentDecoder fileHeader], kHeader,
				[NSNumber numberWithLong:p[2]],kRunNumber,
				[NSNumber numberWithLong:p[1]>>16],kSubRunNumber,
				[NSNumber numberWithLong:kNormalRun],  kRunMode,
				nil] retain];
	
}

- (void) loadRunInfoFromHeader
{
	//pack up some info about the run.
	[runInfo release];
	NSNumber* runNumber    = [currentDecoder headerObject:@"objectInfo",@"DataChain",@"0",@"RunControl",@"RunNumber",nil];
	NSNumber* subRunNumber = [currentDecoder headerObject:@"objectInfo",@"DataChain",@"0",@"RunControl",@"SubRunNumber",nil];

	runInfo = [[NSMutableDictionary dictionaryWithObjectsAndKeys:
				[currentDecoder fileHeader], kHeader,
				runNumber,kRunNumber,
				subRunNumber,kSubRunNumber,
				[NSNumber numberWithLong:kNormalRun],  kRunMode,
				nil] retain];
	
}


- (void) processRunRecord:(unsigned long*)p
{
	unsigned long theDataWord = *(p+1);
	id nextObject = [self objectConnectedTo:ORListenerConnector];
	
	if((theDataWord & 0x8)){
		//heart beat
	}
	else {
		if(theDataWord & 0x1){
			[self loadRunInfoFromRunRecord:p];
			[nextObject runTaskStarted:runInfo];
			[nextObject setInvolvedInCurrentRun:YES];
		}
		else if(theDataWord & 0x10){
			//send prepare sub run
		}
		else if(theDataWord & 0x20){
			[nextObject subRunTaskStarted:runInfo];
		}
		else {
			[nextObject runTaskStopped:runInfo];
			runEnded = YES;
			firstTime = YES;
		}
	}
}

- (void) sendDataArray:(NSArray*)aDataArray decoder:(ORDecoder*)aDecoder
{
	if([aDataArray count]){
		id nextObject = [self objectConnectedTo:ORListenerConnector];
		[nextObject processData:aDataArray decoder:aDecoder];
	}
}

@end