<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>	<head>		<meta http-equiv="content-type" content="text/html;charset=iso-8859-1">		<meta name="generator" content="Adobe GoLive">		<title>Untitled Page</title>	</head>	<body bgcolor="#c5e8ff">		<h2>ORCAScript Overview</h2>		<p>ORCAScript is a minimalistic interpreted programming language that can be used to automate some ORCA run-time tasks. Among its design goals were that it could be interpreted using a relatively simple lex/yacc based interpreter, provide a C-like language that would be easy to learn, and provide all access to most of the objects in an ORCA configuration. ORCAScripts are created and edited using the ScriptTask object. Scripts are automatically entered into the list of tasks managed by the <a href="../TaskMaster/TaskMaster.html">Task Master</a> and can be executed either from there of from the <a href="../Objects/Misc/ScriptTask/ScriptTask.html">ScriptTask</a> object.</p>		<h3>Characteristics</h3>		<p>As an C-like language, ORCAScript has the following characteristics:</p>		<ul>			<li>The syntax is, as much as possible, the same as C			<li>A procedural programming paradigm, with facilities for structured programming			<li>A small set (around 15) of reserved keywords			<li>Function parameters are passed by value			<li>Recursion is supported		</ul>		<p>ORCAScript also has the following specific properties:</p>		<ul>			<li>Variables are untyped and treated internally as NSDecimalNumber objects.			<li>Variables are global in scope within each function			<li>Arrays are allowed			<li>Access to objects in an ORCA configuration is supported using Obj-C syntax			<li>Most C math functions are supported		</ul>		<p>Limitations:</p>		<ul>			<li>With the exception of ORCA configuration object access, there are no pointers			<li>No structures, enums, or typedefs			<li>Strings are allowed only in print and logfile functions<li>In some cases, misspellings of certain keywords (i.e. break) will not be caught by the parser		</ul>		<h2>Language Reference</h2>		<h3>Introduction</h3>		<p>With some limitations, ORCAScript is essentially a sub-set of the 'C' language. A couple of new keywords and some Obj-C syntax are introduced to facilitate interaction with the ORCA run-time.</p>		<p>An introduction, here is the ubiquitous 'hello world' example in ORCAScript:</p>		<address><font size="-1">1</font> function main(a)</address>		<address><font size="-1">2</font> {</address>		<address><font size="-1">3</font>       print (&quot;hello world -- I got passed a = &quot;, a);</address>		<address><font size="-1">4</font>      a<font size="-1">++</font>;</address>		<address><font size="-1">5</font>      return a;</address>		<address><font size="-1">6</font> }</address>		<p>Looks a lot like 'C' doesn't it? Some notes on the example:</p>		<p>Line 1. The <i>main</i> function definition. All scripts must have a <i>main</i> function. Other functions may either precede or follow the <i>main</i> fuction. Note that the variable 'a' is not typed. The only variables that need to be defined are array variables. Unitialized variables are set to zero the first time they are accessed.</p>		<p>Line 3. ORCAScript's output function is <i>print</i>. The bracketing '(' ')' s are optional. This function just outputs its argument list, which is a comma separated list of strings, variables, and constants.</p>		<p>Line 5. When the <i>main</i> function returns the next script in the chain is started. The return value of the <i>main</i> function will be passed into the next script in the chain. If no scripts follow, the return value will be ignored.</p>		<h3>Variables</h3>		<p>Vaiables in ORCAScript are easy-- just use them. Variables are untyped and initialized to zero by default. In general, things should work as you would expect; if you add a float and an integer, the result will be a float. The resulting precision will follow the use of NSDecimalNumber objects. Check with Apple's Cocoa documention if you have questions in this area.</p>		<h3>Arrays</h3>		<p>Arrays must be defined using the keywork <i>array</i> and must be given with a max array size. The syntax is:</p>		<p><i>array anArray[10];</i></p>		<p>Thereafter, the array can be accessed with same syntax as 'C'. The print command will print out the entire array if just the array name is given. For example:</p>		<address>array anArray[4];</address>		<address>anArray[2] = 3.2;</address>		<address>anArray[3] = 1;</address>		<address>print &quot;The array = &quot;,anArray;</address>		<p>will print out the following to the status log:</p>		<p><i>The array = (0,0,3.2,1)</i></p>		<p>Note that the array in this example contained a mix of integer and float values and it works as expected. Stepping beyound the bounds of an array will cause an exception that will cause the script to exit prematurely.</p>		<p>There is one major limitation in the use of arrays -- some operators can not be used. In particular, you can not use any of the operators that assign a value back into the array, i.e. <font size="-1">+=</font>, <font size="-1">-=</font>, <font size="-1">*=</font>, <font size="-1">++</font>, etc... And unfortunately, those constructs will parse correctly--you'll just get a run-time exception when they are executed.</p>		<h4>Predefined Constants</h4>		<p>There are some predefined constants. The values should be obvious:</p>		<address>true, false, TRUE, FALSE</address>		<address>yes, no, YES, NO</address>		<address>nil, NUL</address>		<h3>Functions</h3>		<p>Functions take the form:</p>		<p><i>function</i> name <i>(</i> [optional comma separated list of arguments]<i>)</i></p>		<p>ORCAScript follows C in that you must define a <i>main</i> function. Other functions may be defined anywhere in the script, either before or after the <i>main</i> function--it doesn't matter. Calling a function is just in C. Here's an example:</p>		<address>function main()</address>		<address>{</address>		<address>    a = valuePlusOne(3);</address>		<address>    print a;</address>		<address>}</address>		<address></address>		<address>function valuePlusOne(x)</address>		<address>{</address>		<address>    return x+1;</address>		<address>}</address>		<p>That example will obviously print out 4.</p>		<p>Since functions can be directly or indirectly recursive, care must be taken to ensure program correctness to prevent infinite recursion. Just like in C and other languages, this can not be checked for and would cause a crash of the entire ORCA environment.</p>		<h3>Loops</h3>		<p>All of the 'C' language loop constructs are allowed.</p>		<address>do {</address>		<address>    &lt;statements&gt;</address>		<address>}while(&lt;condition&gt;);</address>		<address></address>		<address>while(&lt;condition&gt;) {</address>		<address>    &lt;statements&gt;</address>		<address>};</address>		<address></address>		<address>for(i=0;i&lt;10;i++){</address>		<address>  &lt;statements&gt;</address>		<address>}</address>		<p>The <i>break</i> and <i>continue</i> statements work same as in 'C'.</p>		<p>The <i>exit </i>statement causes the script to exit completly and return 0;</p>		<h3>Flow Control and Branching</h3>		<p>All of the 'C' language flow control constructs are allowed.</p>		<address>if(&lt;condition&gt;){</address>		<address>    &lt;statements&gt;</address>		<address>}</address>		<address>else {</address>		<address>    &lt;statements&gt;</address>		<address>}</address>		<address></address>		<address>switch(&lt;variable&gt;){</address>		<address>    case &lt;val&gt;:</address>		<address>        &lt;statements&gt;</address>		<address>    break;</address>		<address>    ...</address>		<address>    ...</address>		<address>    default:</address>		<address>        &lt;statements&gt;</address>		<address>    break;</address>		<address>}</address>		<address></address>		<h4>Printing and Logging</h4>		<p>Printing is a cross between 'C' and 'C<font size="-1">++</font>'.  A list of arguments are just printing in the same order as defined. The syntax is:</p>		<p><i>print [(] &lt;list of variables and or strings&gt; [)];</i></p>		<p>Note that the bracketing parentheses are optional. Arrays may part of the list of variables to be printed and will be printed as a parentheses bracketed list.</p>		<p>Examples:</p>		<address>for(i=0;i&lt;6;i++){</address>		<address>      print &quot;The variable is: &quot;,i;</address>		<address>}</address>		<p>Will print out:</p>		<address>The variable is: 0</address>		<address>The variable is: 1</address>		<address>The variable is: 2</address>		<address>The variable is: 3</address>		<address>The variable is: 4</address>		<address>The variable is: 5</address>		<h4>Printing functions</h4>		<p>There are some functions to help format printed output. They are:</p>		<address>hex(&lt;var&gt;)</address>		<p>The <i>hex()</i> function takes a single argument and returns a hex value in string format.</p>		<address><i>string(&lt;list of variables and strings&gt;);</i></address>		<p>The <i>string()</i> function takes a comma separated list of  arguments and format the result into a string. </p>		<p>Examples:</p>		<address><i>print string(&quot;The hex value of  255 is &quot;,hex(255));      //outputs &quot;The hex value of 255 is 0xff&quot;</i></address>		<address><i>print hex(255);    //outputs 0xff</i></address>		<h4></h4>		<h4>Logging to Output Files</h4>		<p>Printing is a cross between 'C' and 'C<font size="-1">++</font>'. A list of arguments are just printing in the same order as defined. The syntax is:</p>		<p><i>logfile [(] &lt;list of variables and or strings that make a path name&gt; [)];</i></p>		<p>Examples:</p>		<address><i>logfile &quot;~/MyOutputLog&quot;,10 ; //the output file is now &quot;MyOutputLog10&quot; in your home dir.</i></address>		<address><i>print &quot;HELLO&quot;;                            //outputs to both the status log and to MyOutputLog10 file.</i></address>		<p>Note that output files are never deleted. Output is appended to the end of existing files. If you wish to start a new empty file with the same name, you must manually delete the old file.</p>		<h4>Supported Math functions</h4>		<p>The supported math functions include:</p>		<address>pow(), sqrt(), ceil(), floor(), round(), cos(), acos() </address>		<address>sin(), asin(), tan(), atan(), abs(), exp(), log(), log10()</address>		<address></address>		<h4>Integration With ORCA</h4>		<p>It is simple to interact with many of the objects in an ORCA configuration. There basically two steps:</p>		<ol>			<li>Get an object reference to an ORCA object			<li>Send a message to that object		</ol>		<p>To get an object reference, use the <i>find()</i> function, the syntax is :</p>		<address><i>objRef = find(&lt;ORCA Object Class Name&gt;);  or</i></address>		<address><i>objRef = find(&lt;ORCA Object Class Name&gt;,&lt;slot or tag #&gt;);  or</i></address>		<address><i>objRef = find(&lt;ORCA Object Class Name&gt;,&lt;crate #&gt;,&lt;slot or tag #&gt;); </i></address>		<address></address>		<p>If the object is NOT a card object and tag # is left off, the first object found will be used.</p>		<p>If the object IS a card object, the crate number will default to 1 and the only the first crate will be searched for objects. For cards, you must supply at least the slot number. For CAMAC and Auger cards, use the station number.</p>		<p>Once you have the objRef you can use regular ObjC syntax to send a message to the object. Here's an example:</p>		<address><font size="-1">1</font> rc = find(ORRunMode);</address>		<address><font size="-1">2</font> if([rc isRunning])print &quot;Yes--Running&quot;;</address>		<address><font size="-1">3</font> else print &quot;No-- NOT Running&quot;;</address>		<p>Line 1: Finds the Run control object in the configuration.</p>		<p>Lines 2: Sends a 'isRunning' message to the run control object, which returns a bool.</p>		<p>Lines 2,3: Print out the result.</p>		<address><font size="-1">1</font> shaper = find(ORShaperModel,2);</address>		<address><font size="-1">2</font> [shaper setThreshold: chan withValue:aValue];</address>		<address><font size="-1">3</font> print &quot;The Theshold value for channel &quot;, chan, &quot;is &quot;,[shaper threshold:chan];</address>		<p>Line 1: Finds the Shaper card object in slot 2. (crate # is defaulted to 1)</p>		<p>Line 2: Sets the threshold for one of the channels.</p>		<p>Line 3: Reads back and prints out the threshold.</p>		<p><b>Note:</b> A couple of things to take note about talking when talking to ORCA objects.</p>		<ul>			<li>You can not call methods that take structures (i.e. NSRange structures) as arguments. The exceptions are the NSPoint and NSRect structures. Create a NSPoint struct using the <i>point(x,y) </i>fuction and the NSRect struct with <i>rect(x,y,w,h)</i>.<li>You can not call methods that return stuctures.			<li>Arrays should be OK as arguments and return values.			<li>You can only access Objects in the configuration. Other objects, such as the main document, or the Alarm Master can not be reached. I may open up the Alarm Master, as it may be useful to have scripts post alarms.					<li>It is OK to pass the object pointer to functions and it is recommended that you do so, as finding objects is a relatively expensive operation and it is much more efficient to only find them once.		</ul>		<h4>Special ObjC functions</h4>		<address>point(x,y) 			                       //makes a NSPoint object</address>		<address>rect(x,y,w,h) 		                   //makes a NSRect object</address>		<address>pointx(&lt;point structure&gt;) //returns x value</address>		<address>pointy(&lt;point structure&gt;) //returns y value</address>		<address>rectx(&lt;rect structure&gt;)    //returns x value</address>		<address>recty(&lt;rect structure&gt;)    //returns y value</address>		<address>recth(&lt;rect structure&gt;)    //returns h value</address>		<address>rectw(&lt;rect structure&gt;)   //returns w value</address>		<h4>Other Special Functions</h4>		<p>There are some special functions:</p>		<address>waituntil(&lt;condition&gt;);                 //waits until the condition is true, always returns true</address>		<address>waituntil(&lt;condition&gt;,&lt;#secs&gt;); //waits until the condition is true OR for # seconds. </address>		<address>                                                     //returns true is &lt;condition&gt; is met, false if timed-out.</address>		<address>sleep(&lt;duration&gt;);</address>		<address>postalarm(&lt;alarmName&gt;,&lt;alarmSeverity&gt; [,&lt;alarmHelp&gt;]);</address>		<address>clearalarm(&lt;alarmName&gt;);</address>		<address></address>		<p><b>Note:</b> The <i>waituntil()</i> function is only useful if the condition can change. This means you should only call it where the condition is an ORCA object call. An example:</p>		<address><font size="-1">1</font> rc = find(ORRunModel);</address>		<address><font size="-1">2</font> waituntil([rc isRunning]);</address>		<address><font size="-1">3</font> print (&quot;Yep, we are running&quot;);</address>		<address></address>		<p>Line 1: Finds the Run Control object.</p>		<p>Line 2: Execution will stop here until a run is in progress.</p>		<p>Line 3: When the run starts execution will continue here.</p>	</body></html>